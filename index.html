<!DOCTYPE html>
<html lang="en">
<!-- Animated Covid-19 Maps -->
<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->  
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-180307641-1"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-180307641-1');
    </script>
  <meta charset="utf-8"/>
  <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate" />
  <meta http-equiv="Pragma" content="no-cache" />
  <meta http-equiv="Expires" content="0" />
  <meta property="og:image" content="./images/preview.png" />
  <meta name="description" content="COVIZ is an open-source data visualization project focused on innovative cartography and animated mapping of the Covid-19 pandemic. Our project is situated in a cartographic analysis of other dashboards created by state, city and country governments, university research groups such as the John Hopkins University CSSE, and private enterprises such as Worldometer, 1point3acres and ncov2019.live. The COVIZ project is unique in its combination of principled cartographic symbolization, animation (using D3), hand-drawn cartograms and choice of epidemiological variables such as recent weekly average new case counts and positive test ratios.">
  <meta name="keywords" content="data visualization, cartography, animation, epidemiology, Covid-19, pandemic, dashboards, COVIZ, EIU, eastern illinois university">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="stylesheet" href="d3_map_styles.css"> 
  <link href="https://fonts.googleapis.com/css2?family=Montserrat:ital,wght@0,200;0,400;0,600;1,200;1,400;1,600&display=swap" rel="stylesheet">
 <link href="https://fonts.googleapis.com/css2?family=B612+Mono&display=swap" rel="stylesheet">
  <title>COViz</title>
  <script src="jquery-3.4.1.js"></script>
  <script src="jquery.csv-0.71.min.js"></script>
  <script src="papaparse.min.js"></script>
  <script src="d3.v5.js" charset="utf-8"></script>
  <script src="utils.js"></script>  
  <script src="data/cdc/data_cdc.js"></script>
  <script src="data/states_covidtracking_TEMPLATE/data_covidtracking_states.js"></script>
  <script src="data/counties_jhu/data_counties_JHU.js"></script>
  <script src="data/canada_provinces_odwg/data_canada_provinces_odwg.js"></script>
  <script src="data/Europe_jhu/data_Europe_JHU.js"></script>
  <script src="d3-simple-slider.min.js"></script>
  <script src="ResizeSensor.js"></script>
  <script src="legend_susielu.js"></script>
  <script src="themes/themes_basic_pack.js"></script>
</head>

<body>
	<!-- What user sees before scrolling -->
	<div id="opening_screen">
		<!-- Top band with web page title -->
		<div id="deprecation">
			<span id="warning">
			This site is no longer being maintained.</span><br>
			<span id="warningdetail">	Data sources used in this site are inconsistent and may not be properly represented. Maps and data presented here should not be relied on for analysis. 
			</span>
			</div>
		<div id="ribbon">	
			
			<div id="logo" style="float:left; margin-left: 0.5ex; height: 90%;">
				<img src="images/EIUSquareWhite.png" style="height: 100%;">
			</div>
			<div id="pagetitle">
					COViz: The Covid-19 Open Visualization Project 
			</div>
			
			<div id="about-link" class="menu">
			<a href="#contributors" style="color: #FFFFFF; font-style: italic;" tabindex=2>contributors</a>
			</div>
			<div id="other-link" class="menu">
			<a href="#about" style="color: #FFFFFF; font-style: italic;" tabindex=1>about</a>
			</div>
			
		</div>
		<!-- Bottom left, map & legends -->
		<div id="map_panel">
			<div id="map_top">
				<div id="map_title_left"></div>
				<div id="map_title_center"></div>
				<div id="map_title_right"></div>
			</div>
			<div id="map"></div>
			<div id="mapbottom">
                <div id="circleLegend"></div>
				<div id="legend"></div>
			</div>
		</div>
		<!-- Bottom right, options for region & theme -->
		<div id="options_panel">
			<div id="options">
				<div id = "messagearea">
					<p><i>Loading data, please wait...</i></p>
				</div>
				<div id="vertical_center_wrapper">
				<div id="vertical_center">
					<div id="selection_area">
						
						<div id="regionlabel">
							<b>Region:</b>
						</div>
						<div id="regioncontrol">
							<select class="rectangular_button select-css" id="dataSourceSelector">
							</select>	
							<select class="rectangular_button select-css" id="dataFilterSelector" size="1" style="display:none">
							</select>			
						</div>
						<div id="regiondescription">
						</div>
						
						<div id="zoomlabel">
						</div>
						<div id="zoomcontrol">
							<button id="zoomUp"  class="big_button" data-tooltip-position="bottom" data-tooltip="Zoom Out"><b>&#10134;</b></button>
							<p id="zoomUpLabel"></p>
						</div>
						
						<div id="themelabel">
							<span><b>Map Theme:</b></span>
						</div>
						<div id="themecontrol">
							<select class="rectangular_button select-css" id="themeSelector">
							</select>
						</div>
						<div id="themedescription">
						</div>
						
						<div id="maptypelabel">
							<b>Map Type:</b>
						</div>
						<div id="maptypecontrol">
							<span>
								Map
								<label class = "switch">
								<input id="carttoggle" type="checkbox">
								<span class="slider round"></span>
								</label>
								<a id="cartOptLbl" > Cartogram</a>
							</span>				
						</div>
						<div id="maptypedescription">
						</div>
					</div>
				</div>
				</div>
			</div>
			<div id="time_controls">
			
				<button class="big_button" id="play-button" data-tooltip-position="bottom" data-tooltip="Play/Pause">►</button>
				
					<span class="dot" id="Slowest" data-tooltip-position="bottom" data-tooltip="Slowest" onclick="delayDots(0)"></span> 
					<span class="dot" id="Slower" data-tooltip-position="bottom" data-tooltip="Slower" onclick="delayDots(1)"></span> 
					<span class="dot" id="Normal Speed" data-tooltip-position="bottom" data-tooltip="Normal Speed" onclick="delayDots(2)"></span>
					<span class="dot" id="Faster" data-tooltip-position="bottom" data-tooltip="Faster" onclick="delayDots(3)"></span> 
					<span class="dot" id="Fastest" data-tooltip-position="bottom" data-tooltip="Fastest" onclick="delayDots(4)"></span>  
				
				<button class="big_button" id="slower-button" data-tooltip-position="bottom" data-tooltip="Decrease Speed">◀◀</button>
				<button class="big_button" id="faster-button" data-tooltip-position="bottom" data-tooltip="Increase Speed">▶▶</button> 
				<button class="big_button" id="loop-button" data-tooltip-position="bottom" data-tooltip="Stop/Repeat">↻</button>
			</div>
			<div id="slider"></div>
            <div id="datePicker">
				<div id="datepickers" style="min-width: 100%">
					<div style="width: 45%; float: left;">
						<input type="date" name="field1" min="minDate" max="maxDate" id="startDatePicker" onchange="changeDateRange('user');" />
					</div>
					<div style="width: 45%; float: right; text-align: right;">
						<input type="date" name="field2" min="minDate" max="maxDate" id="endDatePicker" onchange="changeDateRange('user');" />
					</div>
				
					<div style="margin: 0 auto; text-align: center; display: inline-block; min-width: 100%;">
						<input class="rectangular_button" type="reset" value="today" onclick="resetDateRange(0)"/>
						<input class="rectangular_button" type="reset" value="last 30 days" onclick="resetDateRange(30)"/>
						<input class="rectangular_button" type="reset" value="last 60 days" onclick="resetDateRange(60)"/>
						<input class="rectangular_button" type="reset" value="all dates" onclick="resetDateRange()"/>
						
					</div>
				</div>


            </div>
			</div>
		</div>
	<div id="below_screen">
		<div class="doc_section_title" id="about">
			<div style="float: left"><H3> About </H3></div>
			<div style="float: right"><a href="#">top</a></div>
		</div>
			<p>
			The Covid-19 Open Visualization (COViz) project is a modular open-source web toolkit for 
			hybrid map/graph visualization of COVID-19 risk burden, resource and testing sufficiency 
			and trajectories over time. In contrast to many dashboards that are data-driven and/or 
			built on proprietary software, COViz is an efficient, lightweight open platform that 
			focuses on use of sound cartographic principles to construct targeted visualizations 
			that intuitively communicate information relevant to specific epidemiological questions.
			These include:
			</p>
			<ul>
			<li>What is the current risk of transmission?</li>
			<li>What is the recent trajectory of disease burden and resource availability?</li>
			<li>How great is the cumulative burden of disease?</li>
			<li>Are resources and testing sufficient?</li>
			</ul>
			<p>
			To visually communicate answers to these questions, COViz aims to combine adherence to 
			traditional cartographic principles with innovative map forms and easy-to-use 
			animation/interaction components.
			</p>
			<H4>
			Traditional Cartographic Principles
			</H4>
			<ul>
			<li>All maps communicate rates per population. Raw case counts, hospitalizations and 
				deaths are meaningless without the context of the population within which they 
				are occurring.</li>
			<li>Rates are expressed using sequential color schemes, following the principles of 
				choropleth mapping.</li>
			<li>Raw counts, when shown, are expressed using proportional symbols, as symbol sizes 
				are intuitively associated with amounts.</li>
			<li>District polygons are highly generalized so that the focus is on the thematic 
				information, not the intricacies of the coastline.</li>
			</ul>
			<H4>
			Innovative Map Forms
			</H4>
			COViz features the use of cartograms. Also known as “population maps” and “density 
			equalizing map projections”, cartograms have been used in epidemiology since 
			<a href="https://ajph.aphapublications.org/doi/10.2105/AJPH.17.4.316"> at least the 
			1920s </a> to display districts at a size proportional to their underlying population. 
			This gives a better sense of the relative distribution of disease within the population. 
			While they take a little getting used to, cartograms enable certain advantages for visual 
			inference:
			<ul>
			<li>When symbols (e.g. circles) are used to show raw case counts, the case rate 
				(cases per population) can be inferred visually by the proportion of each 
				district occupied by the circle.</li>
			<li>When sequential colors (e.g. light to dark) are used to show case rates, the 
				total number of cases is proportional to the darkness value multiplied by the 
				size of the state.</li>
			<li>Symbols on a cartogram will have less overlap than on a regular map.</li>
			</ul>
			
			<H4>
			Animation and Interaction
			</H4>
			Some cartographic techniques that work well on static maps break down in animated sequences. We are currently experimenting with ways to enhance visual clarity on the animated timelines.
			
			
			<br>
			This is an open-source project. You are free to download, customize, modify data sources and 
			incorporate into your own website, with the caveat that no warranty is provided. 
			<br><br>
			Keyboard shortcuts (these work inconsistently at the moment):<br>
			<table style="border: none">
				<tr>
					<td>T</td>
					<td>Place focus on the theme selector</td>
				</tr>
				<tr>
					<td>&larr; &rarr;</td>
					<td>Move along timeline (when focus off var. sel.)</td>
				</tr>
				<tr>
					<td>L,P</td>
					<td>Toggle between land and population map types</td>
				</tr>
			</table>
			<p><i>(click on any state for data values)</i></p>
			<br>
		<div class="doc_section_title" id="contributors">
			<div style="float: left"><H3> Contributors </H3></div>
			<div style="float: right"><a href="#">top</a></div>
		</div>			
			<p>This website is being developed by the <a href="https://www.eiu.edu/gisci/">EIU GIScience Center</a>. Data comes from <a href="https://covidtracking.com/">covidtracking.com</a>, the <a href='https://github.com/ishaberry/Covid19Canada'>COVID-19 Canadian Open Data Working Group</a>, and the <a href="https://systems.jhu.edu/"> Center for Systems Science and Engineering</a> at John Hopkins University. Coding performed by:</p>
			<table style="border: none">

				<tr>
					<td><img src="images/kronenfeld 2018.jpg" width="60" height="75"></td>
					<td style="padding-right: 10px; vertical-align:middle">
						<b>Barry Kronenfeld</b><br>
						Director, GIScience Center, Eastern Illinois University
					</td>
				</tr>
				<tr>
					<td><img src="images/Kwang il Yoo_photo.jpg" width="60" height="75"></td>
					<td style="padding-right: 10px; vertical-align:middle">
						<b>Kwang-il Yoo (Jason)</b><br>
						PSM in GIScience, Eastern Illinois University
					</td>
				</tr>
				<tr>
					<td></td>
					<td style="padding-right: 10px; vertical-align:top">
						<b>Sushma Saragadam</b><br>
						PSM in GIScience, Eastern Illinois University
					</td>
				</tr>
				<tr>
					<td></td>
					<td style="padding-right: 10px; vertical-align:top">
						<b>Sarah Kronenfeld</b><br>
						University of Toronto
					</td>
				</tr>
			</table>
			<br>
			<p>Latest project updates can be found on our <a href = "https://github.com/EIU-GIScience-Center/covid19map">github repository</a>. This is a work in progress. Feel free to send <a href="mailto: bjkronenfeld@eiu.edu">comments or feedback</a>.</p>
			<br><br>
	</div>
<script>
	/*
	Global variables used throughout script.
	Please keep these to a minimum!
	*/
	var active_feature = null; // currently selected
	var active; // are we still using this???
	var oncartogram = false; // map/cartogram toggle
	var curDate = null; // current date
	var slider;
	var slider_svg;
	var slider_update_duration = 750;
	// map objects
	var mapsvg; // svg containing map 
    var districtPaths;
	var circles; // svg group within mapsvg containing smaller circle for each state
	// map theme functions and values
	var theme;
	var dataSource;
	var data_transitioning = false; // Flag to prevent duplicate data loading
	var baseFeatures;
	var cartogramFeatures;
	var curZoomFunc;
	var dataSourceFilter;
    var mapdiv;
	var mapWidth;
	var mapHeight;
	var legendChoropleth;
	var choroplethColorScale; // scale function for legend (doesn't include white for zero)
	var lowValColor = null;
	var highValColor = null;
	var lowVal;
	var highVal;
	var dailyChomin;
	var dailyChomax;
	// circle Area (i) = fillRatio * value(i) /(lambda*R)
	var fillRatio = 0.35
	var lambda // population per screen area
	var R // rate per population
	
    var timer;
	var touring = false; // if true, we are in the middle of an animated tour
	var busy = false; // if true, user controls will not work
	var defaultPlayStartID = 35; // the day to start playing from when the user plays from the end
	var playStartID, playEndID; // the start and end dates of animation
	var delayIntervals = [300,200,135,90,60];
	// loading
	function handlePageLoading(){
		document.getElementById("messagearea").innerHTML="<p><i>Loading data, please wait...</i></p>"


		/*
		msgdiv = document.getElementById('messagearea')
		msgdiv.style.position='absolute';
		msgdiv.style.zIndex=999;
		msgdiv.style.height='100%';
		msgdiv.style.width='100%';
		msgdiv.style.backgroundColor='rgba(1,0,0,0.3)';
		msgdiv.class="centered";
		*/

	}
	handlePageLoading();
	
	// array of themes
	// each theme should be defined in a separate file; see theme_new_cases.js for a template
	var themes = [
		themeWeeklyCases,
		themeWeeklyDeaths,
		themeWeeklyChangeCases,
        themeWeeklyChangeDeaths,
		themeWeeklyPositivityRate,
		themeWeeklyCaseMortality,
		themeDailyCases,
		themeDailyChangeCases,
		themeDailyDeaths,
        themeCumulativeCases,
		themeCumulativeDeaths,
        themeCumulativePositivityRate,
		themeCumulativeCaseMortality        
	]

	// array of data sources
	// each data source should be defined in a separate file; see data_covidtracking_states.js for a template
	var dataSources = [
		data_cdc()]
		/*,
		dataODWG_Canada_Provinces(),
		dataJHU_USA_Counties()
	]*/

	function themeAvailable(t,ds){
		// checks if theme t is availabe with data source ds
		if(t){
			if(ds){
				var req_var = t.requiredVariables;
				var themeValid = true;
				for(j=0;j<req_var.length;j++){
					if(ds.variableNames.includes(req_var[j]) == false){
						themeValid = false;
					}
				}
				return themeValid;
			} else {
				return false
			}
		} else {
			return false
		}
	}

	function addThemesToSelector(datasource){
		// get selector object
		const themeSelector = document.getElementById("themeSelector");
		// clear existing themes
		themeSelector.options.length = 0;
		// add all themes that are valid with current data source
		for (i=0; i<themes.length; i++) {
			if(themeAvailable(themes[i],dataSource)){
				const option = document.createElement("option");
				option.text=themes[i].themeName;
				themeSelector.add(option);
			}
			
		}
		
	}

	function addDataSourcesToSelector(dataSourcesToAdd){
		// Add datasets to the selector
		const dataSourceSelector = document.getElementById("dataSourceSelector");
		for (i=0; i<dataSourcesToAdd.length; ++i) {
			var thisDataSrc = dataSourcesToAdd[i];
			if(thisDataSrc.showInSelector){
				const option = document.createElement("option");
				option.text=thisDataSrc.dataSourceName;
				dataSourceSelector.add(option);
			}			
		}
	}
	addDataSourcesToSelector(dataSources);

	function showFilterSelector(){
		var filterSel = document.getElementById("dataFilterSelector");
		var baseFeat = baseFeatures;
		if(baseFeat != undefined){
			var s = baseFeat.features.length+1;
			// add no filter option
			const option = document.createElement("option");
			option.text="(all)";
			filterSel.add(option);
			// add individual filters
			for (let featID = 0; featID < baseFeat.features.length; featID++){
				var curFeat = baseFeat.features[featID];
				var filterText = dataSource.getChildFilter(curFeat);
				const option = document.createElement("option");
				option.text=filterText;
				filterSel.add(option);
			}
		}
	}

	function truncateCellsAndLabels(cells,labels, lowVal, highVal){
		// get indices of highest cell below lowVal, and lowest cell above highVal
		if(lowVal < 0){lowVal = 0;}
		var lowIndex=0;
		var highIndex=cells.length-1;
		var gotHigh = false;
		for(i=0;i<cells.length;i++){
			if (cells[i] < lowVal){lowIndex = i;}
			if(gotHigh == false){
				if(cells[i] > highVal){
					highIndex = i; 
					gotHigh = true;
				}
			}
		}
		// remove first and last cell/label if too close to lowVal and highVal
		var last_lb = theme.choroplethValueScale(cells[highIndex-1]);
		var last_ub = theme.choroplethValueScale(cells[highIndex]);
		
		right_buffer_proportion = (last_ub-theme.choroplethValueScale(highVal))/(last_ub-last_lb)
		if(right_buffer_proportion > 0.5 && cells.length > 2){highIndex -=1;};
		// make sure there are at least four cells
		while(highIndex-lowIndex <3 && (lowIndex > 0 || highIndex < cells.length-1)){
			highIndex += 1;
			if(highIndex > cells.length-1){highIndex = cells.length-1;};
			lowIndex -= 1;
			if(lowIndex < 0){lowIndex = 0;};
		}
		
		// slice out the corresponding section of the cells and labels
		cells = cells.slice(lowIndex, highIndex+1);
		labels = labels.slice(lowIndex, highIndex+1);
		// replace first and last with min/max
		cells[0] = lowVal;
		labels[0] = theme.customLabel(lowVal);
		var n = cells.length;
		cells[n-1] = highVal;
		labels[n-1] = theme.customLabel(highVal);
		
		// avoid labels in adjacent cells
		if(labels[1] != ''){
			labels[1]='';
			labels[2] = theme.customLabel(cells[2]);
		}
		if(labels[n-2] != ''){
			labels[n-2] = '';
			labels[n-3] = theme.customLabel(cells[n-3]);
		}
		return [cells,labels];
	}

	// Computes quartile values for a given date range
	function quartileValues(valueFunction,startDateID, endDateID){
		// do some error checking before processing the input
		var baseFeat = baseFeatures;
		if(baseFeat, startDateID == undefined){
			return null;
		} else {
			// Prcocess the input
			// Create an array to hold value-population pairs
			var valPops = []; 
			var sumPop = 0; // keep track of total poulation
			// get value-population for every feature across date range
			// sample for efficiency - minimum 10 samples
			var datestep = Math.round((endDateID-startDateID)/10);
			if(datestep < 1){datestep=1;}
			if(datestep > 10){datestep=10;} // don't skip more than 10 days
			if(datestep % 7==0){datestep=datestep-1;} // avoid weekly periodicity
			
			for (let dateID = startDateID; dateID < endDateID+1; dateID+=datestep){
				var thisDate = dataSource.dates[dateID];
				for (let featID = 0; featID < baseFeat.features.length; featID++){
					var curFeat = baseFeat.features[featID];
					var curVal = valueFunction(curFeat, thisDate);
					var curPop = dataSource.getPopulation(curFeat);
					valPops.push([curVal,curPop]);
					sumPop += curPop;
				}
			}
			
			// sort value-population pairs by value
			valPops.sort((a,b) => (a[0] > b[0]) ? 1 : -1);
			// get min & max
			var minVal = valPops[0][0];
			var maxVal = valPops[valPops.length-1][0];
			// get 1st quartile, median and 3rd quartile in a loop
			var q1Pop = sumPop/4;
			var q2Pop = q1Pop*2;
			var q3Pop = q1Pop*3;
			var cumulativePop = 0;
			var q1Val, q2Val, q3Val;
			for(let i = 0; i < valPops.length; i++){
				var nextPop = cumulativePop + valPops[i][1];
				if(cumulativePop <= q1Pop && nextPop >= q1Pop){q1Val = valPops[i][0];}
				if(cumulativePop <= q2Pop && nextPop >= q2Pop){q2Val = valPops[i][0];}
				if(cumulativePop <= q3Pop && nextPop >= q3Pop){q3Val = valPops[i][0];}
				cumulativePop = nextPop;
			}
			// return quartiles
			return [minVal,q1Val,q2Val,q3Val,maxVal];
		}
	}
    
	function updateChoroplethValueRange(callerLabel){
		funcStart = performance.now(); // measure performance
		// get date range
        startDateID = dataSource.dates.indexOf(ymdToMdy(document.getElementById('startDatePicker').value))
        endDateID = dataSource.dates.indexOf(ymdToMdy(document.getElementById('endDatePicker').value))
		if(startDateID == -1){startDateID = 0;}
		if(endDateID == -1){endDateID = dataSource.dates.length-1;}
		// get function for determining values for each district & date
		//var choroFunc = theme.quickChoroplethValueFcn; // use quick function
		var choroFunc = theme.choroplethValueFcn; // use quick function
		if(choroFunc == undefined){choroFunc = theme.choroplethValueFcn;} // use full calculation if there is no quick function
		if(endDateID-startDateID < 50){choroFunc = theme.choroplethValueFcn;} // use full calculation unless we've got a lot of data to process
		// calculate quartile values
		var qvals = quartileValues(choroFunc,startDateID,endDateID);
		if(qvals != null){
			//dailyChomin = qvals[0];
			//dailyChomax=qvals[4];
			theme.legendmin = qvals[0];
			theme.legendmax = qvals[4];
			// determine legend span, and expand range to include legend span
			if(theme.fixedChoroplethLegend){
				truncatedCells = theme.choroplethCells;
				truncatedLabels = theme.choroplethLabels;
			} else {
				// truncate legend cells and labels to low and high values
				[truncatedCells, truncatedLabels]=truncateCellsAndLabels(theme.choroplethCells, theme.choroplethLabels, theme.legendmin,theme.legendmax);
				
				theme.legendmin = truncatedCells[0]; // dailyChomin = truncatedCells[0];
				theme.legendmax = truncatedCells[truncatedCells.length-1];
				// This is really bad form to use theme.legendmin and theme.legendmax to track low and high values,
				// should be changed to local (module-level) variables
			}
			var domainVals = qvals.map(x => theme.choroplethValueScale(x));
			var unitIntervalScale = d3.scaleLinear()
			.domain(domainVals)
			.range([0,0.25,0.5,0.75,1]);

			if(theme.invertColorScale){
				choroplethColorScale =d3.scaleSequential(function(d){
					return theme.choroplethColorInterpolator(1-unitIntervalScale(theme.choroplethValueScale(d)));
				});
			} else {
				choroplethColorScale =d3.scaleSequential(function(d){
					return theme.choroplethColorInterpolator(unitIntervalScale(theme.choroplethValueScale(d)));
				});		
			}
		}
	}

	function initFixedValueRange(){
		var unitIntervalScale = d3.scaleLinear()
			.domain([theme.choroplethValueScale(theme.legendmin), theme.choroplethValueScale(theme.legendmax)]);
			if(theme.invertColorScale){
				choroplethColorScale =d3.scaleSequential(function(d){
					return theme.choroplethColorInterpolator(1-unitIntervalScale(theme.choroplethValueScale(d)));
				});
			} else {
				choroplethColorScale =d3.scaleSequential(function(d){
					return theme.choroplethColorInterpolator(unitIntervalScale(theme.choroplethValueScale(d)));
				});			
			}
    }

    function loadTheme() {
		// determine the new map theme
		var themeName = document.getElementById("themeSelector").value;		
		// Look for the theme in our theme modules
		const match = themes.find(v => v.themeName == themeName)
		if(dataSource !== undefined){
			if (match) {
				theme = match;
				// show the description of the theme
				document.getElementById("themedescription").innerHTML ="<i>" + theme.briefDescription + "</i>";
				// calculate true legend/color/size scales based on theme parameters
				if(theme.invertColorScale){
					lowValColor = theme.choroplethColorInterpolator(1);
					highValColor = theme.choroplethColorInterpolator(0);
				} else {
					lowValColor = theme.choroplethColorInterpolator(0);
					highValColor = theme.choroplethColorInterpolator(1);
				}	
				loadChoroplethLegend();
				updateMap(null,null,'loadTheme');
			} // found match
		} // datasource is defined
	} // loadTheme function


	var loadData = function(dataSourceName, filterValue=null) {
		if(data_transitioning){
			return new Promise(function(resolve,reject){
				reject('data transitioning, please wait...');
			})
		} else {
			return new Promise(function(resolve,reject){
				// find matching data source
				var match = dataSources.find(v => v.dataSourceName == dataSourceName);
				if(match){
					// for error checking
					error_displayed=false;
					// get promised data object
					match.dataFunc.then(function(the_data_obj){
						// update data source
						dataSource = the_data_obj; // the data object is what we'll call the dataSource
						dataSourceFilter = filterValue;
						if(dataSourceFilter==null){dataSourceFilter = dataSource.defaultFilter;};
						// get rid of any tooltip
						active_feature = null;
						feature_mouseout(null,null);
						// show the description of the data source
						document.getElementById("regiondescription").innerHTML ="<i>" + dataSource.briefDescription + "</i>";
						addThemesToSelector(dataSource); // determine which themes are valid for this data source
						document.getElementById("messagearea").innerHTML="<p><i>Click on a " + dataSource.districtClassLabel + " for details.</i></p>"
						// create a getValue function that can be used in themes
						getValue = function(feat, date, varName, perMillion=false, getIncrease = false){
							var featID = dataSource.getID(feat);
							var val;
							if(dataSource.dateDistrictData == undefined || featID == undefined ){
								val=0;
							} else {
								try{
									val = dataSource.dateDistrictData[date][featID][varName];
								}
								catch(err){
									// sometimes JHU data is missing spaces. try one more time, removing spaces after commas
									/*
									try{
										val = dataSource.dateDistrictData[date][featID.replaceAll(', ',',')][varName];
									} catch(err){
										console.log("ERROR IN loadData");
										console.log("date: " + date);
										console.log("featID: " + featID);
										console.log("varName: " + varName);
										console.log("date data: ");
										return 0;
									}
*/									
								}
							}
							if(perMillion){val = val*1000000/dataSource.getPopulation(feat);}
							if(getIncrease){
								var yesterday = previousDate(date, dataSource.dates);
								if (yesterday != null){
									var yesterdayVal = getValue(feat,yesterday,varName,perMillion,false);				
									val = val-yesterdayVal
								}
							}		
							return val;
						}
						// get features
						baseFeatures = dataSource.baseFeatures(dataSourceFilter);
						cartogramFeatures = dataSource.cartogramFeatures(dataSourceFilter);
						// check to see if there are cartogram features
						if (cartogramFeatures == null){
							// if not, disable map type selector and set cartogram to false
							document.getElementById("carttoggle").disabled=true;
							document.getElementById("carttoggle").checked=false;
							oncartogram = false;
							document.getElementById("cartOptLbl").style.color="#CCCCCC";
						} else {
							// otherwise need to make sure it is visible
							document.getElementById("carttoggle").disabled=false;
							document.getElementById("cartOptLbl").style.color=null;
						}
						// make sure date pickers are valid
						changeDateRange();

						resolve();
					});
				};		
			});
		}
	}
           
	function extendColorScale(initScale,inVal){
		if (lowValColor != null){
			if (inVal <= lowVal){
				return lowValColor;
			} 
		}
		if (highValColor != null){
			if (inVal >= highVal){
				return highValColor;
			}
		}
		return initScale(inVal);
	}
    
	function choroplethColor(feat,date){
		// assign a color based on rate per million
		var featval =theme.choroplethValueFcn(feat,date);
		return extendColorScale(choroplethColorScale,featval);
	}			
    
    // HELPER FUNCTIONS
    function divPathFunc(divid,geojsonObj,padding=0){
    /* returns a "path" function to construct svg paths from geojson features, 
       such that the resulting svg paths fit in the div
        divId:		id of the div to contain the feature paths
        geojsonObj:	geojson feature or feature collection 
        padding:	space between features and edge of div, in pixels
    */
        // get width and height of div
        divid='map';
        mapdiv = document.getElementById(divid); 
            var width = mapdiv.offsetWidth;
            var height = mapdiv.offsetHeight;

        // create 'projection' to fit features to div
        // the geoIdentity function creates a fake projection that just uses the base coordinates
        // the added reflectY function puts a minus sign before the Y coordinate, because SVG y-coordinates are upside-down
        // the added fitExtent function does most of the work. It creates translation and scaling parameters to automatically
        // fit the input features to the box inside the div
        var zoomProjection = d3.geoIdentity()
            .reflectY(true)
            .fitExtent([[padding,padding],[width-padding, height-padding]],geojsonObj);
        // create path constructor using above projection
        var zoomPath = d3.geoPath()
            .projection(zoomProjection);
        // return to sender
        return zoomPath;
    }

	function resize(){
		if(data_transitioning==false){
			if (curDate != null){
				divid='map';
				mapdiv = document.getElementById(divid); // Do not use #
				var width = mapdiv.offsetWidth;
				var height = mapdiv.offsetHeight;
				// update map, legend and slider only if div size has changed
				if(width != mapWidth || height != mapHeight){	
					// record new width/height so we can avoid resizing next time if this doesn't change
					mapWidth = width;					
					mapHeight = height;
					// update map, legend and slider
					var curDateID = dataSource.dates.indexOf(curDate);

					if(oncartogram==true){
						loadMap(cartogramFeatures);
					} else {
						loadMap(baseFeatures);
					}
					updateMap(null,null,'resize',updateR=false);
					var slider_val = Math.round(slider.value());
					slider.value(slider_val);
				}
			}
		}
	}

	// handle resizing
	new ResizeSensor(jQuery('#map'), function(){ 	
		resize();
	});		

	function featureInfoHTML(feature){
		if(theme != undefined){
			if(feature != null){
				// show data
				var realDate = new Date(curDate)
				var monthID = realDate.getMonth()+1;
				var day = realDate.getDate();
				showHTML = "<B>" + dataSource.getLabel(feature) + " (" + monthString(monthID) + " " + day + ")</B><BR>";
				showHTML += theme.tooltipTextFcn(feature,curDate);				
				return showHTML;
			} else {
				return "";
			}
		}
	}

	function transitionMapData(featdata,categories, category){
		return new Promise(function(resolve,reject){
			// zooms to new feature data and then 
			// replaces current map polygons
			data_transitioning=true; // prevent repeated resizing
			circles.remove(); // remove circles while zooming
			// get old and new zoom functions
			var oldZoomPathFunc = curZoomFunc;
			var newZoomPathFunc = divPathFunc("mapdiv",featdata,30);
			localChoroplethColor=function(d){return choroplethColor(d, curDate);};

			// transition old district paths to new zoom
			districtPaths.selectAll('path')
				.transition()
				.duration(3000)
				.attr('d',newZoomPathFunc);
			// create new district paths
			var newPaths = mapsvg.append('g');
			// add new district paths in (invisible)
			newPaths.selectAll('path')			
				.data(featdata.features)
				.enter()
				.append('path')
				.attr('pointer-events', 'all')
				.attr('d',oldZoomPathFunc)
				.attr("class","feature")
				.attr("stroke", "#EEE")
				.attr("stroke-width", "1px")
				.attr("fill", localChoroplethColor) 
				.style('opacity',0)
				.on("click",feature_click)
				.on("mouseover",feature_mouseover)
				.on("touchmove",feature_mouseover,{ passive: true })
				.on("mouseout",feature_mouseout)	
				.transition()
				.duration(3000)
				.style('opacity',1)
				.attr('d',newZoomPathFunc);
			// fade in and zoom new district paths
			districtPaths.transition()
				.duration(5000)
				.style("opacity",0)
				.end()
				.then(() => {
					// remove and replace district paths
					districtPaths.remove();
					districtPaths = newPaths;
					// record new zoom function
					curZoomFunc = newZoomPathFunc;
					// add circles back in (with zero radius...)
					circles = mapsvg.append('g');		
					circles.selectAll('circle')
						.data(featdata.features)
						.enter()
						.append('circle')
						.attr('pointer-events', 'none')
						.attr('d', curZoomFunc)
						.attr("cx", function(d){
							return curZoomFunc.centroid(d)[0];
						})
						.attr("cy", function(d){
							return curZoomFunc.centroid(d)[1];
						})
						.style('stroke-width',1)
						.style('stroke',"#FFFFCC")
						.style('opacity',1)
						.on("click",feature_click)
						.on("touchmove",feature_mouseover,{ passive: true })
						.on("mouseover",feature_mouseover)
						.on("mouseout",feature_mouseout);			
					data_transitioning=false; // prevent repeated resizing, data loading
					resolve();
				})
				.catch(() => {data_transitioning=false;});
			
			
	});}

	function replaceMapData(featdata,categories, category){
		// replaces current map polygons with featdata
		// remove all paths from map
		mapsvg.selectAll("g").remove();
		// mapsvg.remove();
		// create new group for district paths
		districtPaths = mapsvg.append('g');
		// remove and re-create paths in SVG
		curZoomFunc = divPathFunc("mapdiv", featdata, 30);
		districtPaths.selectAll('path')
			//.remove()
			.data(featdata.features)
			.enter()
			.append('path')
			.attr('pointer-events', 'all')
			.attr('d',curZoomFunc)
			.attr("class","feature")
			.attr("stroke", "#EEE")
			.attr("stroke-width", "1px")
			.attr("fill", "#FFFFCC") // function(d){return choroplethColor(d, curDate);})
			.on("click",feature_click)
			.on("touchmove",feature_mouseover,{ passive: true })
			.on("mouseover",feature_mouseover)
			.on("mouseout",feature_mouseout);	

		circles = mapsvg.append('g');
		circles.selectAll('circle')
			.data(featdata.features)
			.enter()
			.append('circle')
			.attr('pointer-events', 'none')
			.attr('d', curZoomFunc)
			.attr("cx", function(d){
				return curZoomFunc.centroid(d)[0];
			})
			.attr("cy", function(d){
				return curZoomFunc.centroid(d)[1];
			})
			.style('stroke-width',1)
			.style('stroke',"#FFFFCC")
			.style('opacity',1)
			.on("click",feature_click)
			//.on("touchstart",feature_click,{ passive: true })
			.on("touchmove",feature_mouseover,{ passive: true })
			//.on("touchend",feature_click,{ passive: true })
			.on("mouseover",feature_mouseover)
			.on("mouseout",feature_mouseout);			
		districtPaths.exit().remove();
	}

	function loadMap(featdata,categories, category, transition=false){
		return new Promise(function(resolve,reject){
		// make sure we have a data source
		if(dataSource !== undefined){		
			divid='map';
			mapdiv = document.getElementById(divid); // Do not use #
			var width = mapdiv.offsetWidth;
			var height = mapdiv.offsetHeight;
			divid = '#' + divid;
			// create svg object inside map div
			if(mapsvg == undefined){
				mapsvg = d3.select(divid)
						.append('svg')
						.attr('width',width)
						.attr('height',height)
						.on('click',reset);		
			}
			if(transition){
				transitionMapData(featdata,categories,category).then(function(){
					resolve();
				});
			} else {
				replaceMapData(featdata,categories,category);
				resolve();
			}
			// end if dataSource is not undefined
		}  else {
			resolve();
		}
	});}

	// toggles between the current base map and cartogram
	function toggle_map(milliseconds=1500, callback){
		if(data_transitioning){
		} else {
			oncartogram = !oncartogram;
			document.getElementById("carttoggle").checked=oncartogram;
			updateMap(milliseconds, callback,'toggle_map', updateR=false);
		}
	}

	// updates the map title based on current selections
	function updateMapTitle(){
		var newtitle= "<b>" + theme.themeName + "</b>";
		document.getElementById("map_title_left").innerHTML=newtitle;
		document.getElementById("map_title_center").innerHTML=datePeriodExpression(curDate, [], dataSource.dates); //theme.dateRange
		if(theme.aggregateLabelFcn == undefined){
			document.getElementById("map_title_right").innerHTML="";
		} else {
			document.getElementById("map_title_right").innerHTML=theme.aggregateLabelFcn(baseFeatures.features,curDate);
		}
	}

	// updates map to the user selected type (map or cartogram) and date
	function updateMap(milliseconds=750, callback, callerLabel, updateR=true){
		// transitions the map features and symbology based on current theme, map type and data source
		// change the text describing the map type
		if(milliseconds==null){milliseconds=750;};
		var mapTypeDescription;
		var tName = theme.themeName.toLowerCase();
		var tUnit = tName.split(" ");
		var dcLabel = dataSource.districtClassLabel;
		var upperdcLabel = dcLabel.slice(0,1).toUpperCase() + dcLabel.slice(1);
		if(Array.isArray(tUnit)){
			tUnit=tUnit[tUnit.length-1];
			tUnit = tUnit.slice(0,-1);
		}
		
		if (oncartogram){
			mapTypeDescription = "The size of each " + dcLabel + " represents its <span style='color: #B37; font-weight: 700'>population</span>.<p><ul>";
			if(theme.circle){
				mapTypeDescription += "<li>Circle sizes represent <span style='color: #B37; font-weight: 700'>" + tUnit + " counts</span>";
				mapTypeDescription += "<li><u>Circle</u> colors  represent <span style='color: #B37; font-weight: 700'>" + tUnit + " rates</span>";
				mapTypeDescription += "<li> Denser circles indicate <span style='color: #B37; font-weight: 700'> higher rates</span>";
			} 
			mapTypeDescription += "</ul></p>";
		} else {
			mapTypeDescription = "The size of each " + dcLabel + " represents its <span style='color: #B37; font-weight: 700'>land area</span>.<p><ul>";
			if(theme.circle){
				mapTypeDescription += "<li>Circle sizes represent <span style='color: #B37; font-weight: 700'>" + tUnit + " counts</span>";
				mapTypeDescription += "<li><u>" + upperdcLabel + "</u> colors represent <span style='color: #B37; font-weight: 700'>" + tUnit + " rates</span>";
				mapTypeDescription += "<li> Circle density is  not meaningful";
			} 
			mapTypeDescription += "</ul></p>";
		}
		document.getElementById("maptypedescription").innerHTML ="<i>" + mapTypeDescription + "</i>";
		divid='map';
			mapdiv = document.getElementById(divid); // Do not use #
			var width = mapdiv.offsetWidth;
			var height = mapdiv.offsetHeight;
			divid = '#' + divid;		
		// transition the map only if the map svg and date are defined
		if(dataSource.dates != undefined){
			
		};
		if(mapsvg !== undefined){
			if(curDate != null){	

				// get features (either map or cartogram)
				var todata; 
				if (oncartogram==false){
					todata=baseFeatures;
				} else {
					todata=cartogramFeatures;
				};
				// get data and choropleth/symbol functions depending on if we're showing a map or cartogram
				var localChoroplethColor;
				var localCircleRadius;
				var localCircleFill = function(d){return choroplethColor(d, curDate);};
				var localFeatureStroke;
				var localCircleStroke;

				// reload legend				
				if(moving==false){
					loadChoroplethLegend();
                    //loadCircleLegend();
				};

				if(theme.circleAreaFcn==0){
					localCircleRadius=0;
				} else {
					localCircleRadius=function(d){
						var cRadius = 
                            Math.sqrt
                            (fillRatio * theme.circleAreaFcn(d,curDate)/(Math.PI*lambda*R));
						return cRadius;
					};
				}
				// adjust symbology depending on whether we're using a regular map or polygon
				if (oncartogram==false){
					// symbology for a regular map
					todata=baseFeatures;
					localChoroplethColor=function(d){return choroplethColor(d, curDate);};
					localFeatureStroke = '#DDD';
					localCircleStroke = "rgba(0, 255, 255,0.35)";
					localCircleFill="rgba(0, 255, 255,0.05)";
				} else {
					// symbology for a cartogram
					todata=cartogramFeatures;
					if(theme.circle == false){
						localChoroplethColor=function(d){return choroplethColor(d, curDate);};
						localFeatureStroke = '#DDD';
						localCircleStroke = localCircleFill;
						localCircleRadius=0;
					} else {
						localFeatureStroke = '#CCC';
						localChoroplethColor='#F5F5F8';
						localCircleStroke = '#FFFFCC';
					}
				}
                curZoomFunc = divPathFunc("mapdiv", todata, 30)
				// transition district polygons
				// console.log("---starting transition---")
				mapsvg.selectAll('path')
					.transition()
					.ease(d3.easeLinear)
					.attr("d",function(d,i){return curZoomFunc(todata.features[i]);})
                    //.attr("d",curZoomFunc) 
					.attr("stroke",localFeatureStroke)
					.duration(milliseconds)
					.attr("fill",localChoroplethColor)
					.style('opacity',1)
					.end()
					.then(() => {
						// console.log("---finished transition---");
						if(callback != undefined){
							callback();
						};
					})
					.catch(error => {}); // without this catch, chrome will show an error
					
					
					//.on("end",callback);	

				// reload legend				
				if(moving==false){
					//loadChoroplethLegend();
                    loadCircleLegend(updateR);
				};

				// transition circle symbols
				mapsvg.selectAll('circle')
					.transition()
					.ease(d3.easeLinear)
                    .attr("d", curZoomFunc)
					.attr("cx", function(d,i){
						var thisFeat = todata.features[i];				
						return curZoomFunc.centroid(thisFeat)[0];
					})
					.attr("cy", function(d,i){
						var thisFeat = todata.features[i];			
						return curZoomFunc.centroid(thisFeat)[1];
					})
					.attr('r',localCircleRadius)
					.style('fill',localCircleFill)
					.style('stroke',localCircleStroke)
					.duration(milliseconds);
				
				// update map title
				updateMapTitle();
				// show info tooltip
				if(active_feature != null){
                    showFeatureInfo(active_feature, true);
                }
			} // end if date is not null
		} // end if mapsvg is not null
	}
    
	function loadChoroplethLegend(){
		// get width
		var legwidth =(document.getElementById("mapbottom").offsetWidth);
		if (theme.circle == true){legwidth = 2*legwidth/3}		
		if(legwidth < 100){legwidth=100;}
		// remove any existing legend
		d3.select("#legend").selectAll('svg').remove();			
		// create svg for new legend
		var legendsvg = d3.select("#legend")
			.append('svg')
			.attr('width',legwidth)
            .attr("height", 120)
		legendsvg.append("g")
		  .attr("class", "legendChoropleth")
		  .attr("transform", "translate(30,40)");
		// update choropleth scale
		if (theme.fixedChoroplethLegend==false && moving==false){
			updateChoroplethValueRange('loadTheme');
		} else {
			initFixedValueRange();
		}   
		
		// create legend
		var truncatedCells
        var truncatedLabels		
        if(theme.fixedChoroplethLegend){
			truncatedCells = theme.choroplethCells;
			truncatedLabels = theme.choroplethLabels;
		} else {
			[truncatedCells, truncatedLabels]=truncateCellsAndLabels(theme.choroplethCells, theme.choroplethLabels, theme.legendmin, theme.legendmax);
			theme.legendmin = truncatedCells[0]; 
			theme.legendmax = truncatedCells[truncatedCells.length-1];
		}
		
        var circlePaddingWidth = 8*truncatedCells.length
        var circleSize = ((legwidth-circlePaddingWidth)/truncatedCells.length)/2
        if (circleSize >= 15){
            circleSize = 15
        }
        if (oncartogram==true & theme.circle == true){
        legendChoropleth = d3.legendColor()
            .shape('circle')
			.cells(truncatedCells)
			.orient("horizontal")
			.labels(truncatedLabels)
			.scale(choroplethColorScale)
            .shapePadding(7)
            .shapeRadius(circleSize)
			.labelOffset(16); 
        } else {
        var numCells = truncatedCells.length;
		legendChoropleth = d3.legendColor()
			.shapeWidth((legwidth-30)/numCells)
			.cells(truncatedCells)
			.orient("horizontal")
			.labels(truncatedLabels)
			.scale(choroplethColorScale)
			.shapePadding(-1)
			.shapeHeight(15)
			.labelOffset(16);
        }
        legendsvg.append("text")
              .attr("x", 15)
              .attr("y", 6)
              .attr("dy", ".35em")
              .style("text-align", "left")
              .text(theme.choroplethLegendTitle);
		// call function to draw legend in svg
		legendsvg.select(".legendChoropleth")
		  .call(legendChoropleth);
	}
    // Circle Legend --------------------------------------------------------------
    
    // the minimum and maximum value across all features on all dates
	function circleValueRange(valuefunction,startDateID, endDateID){
		var funcStart = performance.now();
		if(baseFeatures == undefined){
			return "undefined";
		} else {
			var globalmin = valuefunction(baseFeatures.features[0], dataSource.dates[startDateID]);
			var globalmax = globalmin
			// sample for efficiency - minimum 10 samples
			var datestep = Math.round((endDateID-startDateID)/10);
			if(datestep < 1){datestep=1;}
			if(datestep > 10){datestep=10;}
			for(let i=startDateID; i < endDateID+1; i+=datestep){
				for (let j = 0; j < baseFeatures.features.length; j++){
					var currentValue = valuefunction(baseFeatures.features[j], dataSource.dates[i]);
					if (currentValue > globalmax){
						globalmax = currentValue;
					}	
					if (currentValue < globalmin){
						globalmin = currentValue;
					}
				}

			}
			var funcEnd = performance.now();
			return [globalmin,globalmax];
		}
	}

	// calculates the radius scale factor that will result in the largest circle
	// occupying the given proportion of the feature area
	function updateCircleAreaFac(updateR=true){
		var funcStart = performance.now();
		// determine the largest ratio of value/screenarea
		if(oncartogram){
			features = cartogramFeatures;
		} else {
			features = baseFeatures;
		}

		
		
		if(features == undefined || theme == undefined || $.isNumeric(theme.circleAreaFcn) == true) {
			return "undefined";
		} else {
			// determine the screen factor (ratio of screen coords to geometry coords)
            mapdiv = document.getElementById('map'); // Do not use #
			var width = mapdiv.clientWidth;
			var height = mapdiv.clientHeight;		
			// shortcut variables
			var feats = features.features;
			//var f = theme.quickCircleAreaFcn;
			//if(f==undefined){f=theme.circleAreaFcn;}
			var f = theme.circleAreaFcn;
			// date range
			startDateID = dataSource.dates.indexOf(ymdToMdy(document.getElementById('startDatePicker').value))
			endDateID = dataSource.dates.indexOf(ymdToMdy(document.getElementById('endDatePicker').value))
			
			// find the date with the largest sum of values
			var maxValSum = 0;
			var maxDate = null;
			if(dataSource.filteredData != undefined){
				test = dataSource.filteredData(dataSourceFilter);
			}

			// sample for efficiency - minimum 10 samples
			var datestep = Math.round((endDateID-startDateID)/10);
			if(datestep < 1){datestep=1;}
			if(datestep > 10){datestep=10;}
			for(i=startDateID; i<endDateID+1; i+=datestep){
				var thisDate = dataSource.dates[i];
				var curValSum = d3.sum(feats, x => f(x,thisDate));
				if (curValSum > maxValSum){
					maxValSum = curValSum;
					maxDate = thisDate;
				}
			}			
			
			// get total values, areas and populations
			var totValue = 0;
			var totArea = 0;
			var totPop = 0;
			for (let i = 0; i < feats.length; i++){
				var thisValue = (f(feats[i], maxDate));
				var thisFeatArea = curZoomFunc.area(feats[i]);
				var thisPop = dataSource.getPopulation(feats[i]);
				totValue += thisValue;
				totArea += thisFeatArea;
				totPop += thisPop;
			}
			
			if (totValue == 0){
                return 0;
            } else {
			// update global variables
			lambda = totPop / totArea
			if(updateR){
				R = totValue/totPop;
			}
			// end timing
			var funcEnd = performance.now();
            }
		}
    }


    
    //Load circle legend
    function loadCircleLegend(updateR=true) {		
		var legwidth = (document.getElementById("circleLegend").offsetWidth);
		legwidth = $("#map_panel").width();
		legheight = $("#circleLegend").height();
		// remove any existing legend
        d3.select("#circleLegend").selectAll('svg').remove();
		if(theme.circle){
			// calculate circle parameters
			updateCircleAreaFac(updateR)
			minDateID = dataSource.dates.indexOf(ymdToMdy(document.getElementById('startDatePicker').value))
			maxDateID = dataSource.dates.indexOf(ymdToMdy(document.getElementById('endDatePicker').value))
			var circleFunc = theme.quickCircleAreaFcn; // use quick function			
			if(circleFunc == undefined){circleFunc = theme.circleAreaFcn;} // use full calculation if there is no quick function
			if(endDateID-startDateID < 50){circleFunc = theme.circleAreaFcn;} // use full calculation unless we've got a lot of data to process
			
			var cirMinMax = circleValueRange(circleFunc,minDateID, maxDateID);
			var cirRadmin = cirMinMax[0];
			var cirRadmax = cirMinMax[1];
			
			// find minimum and maximum circle radius
			var maxCircleRadius=function(d){
				var cRadius = Math.sqrt(fillRatio * cirRadmax/(Math.PI*lambda*R));
				if (cRadius >= 43){
					return 43
				} else {
				return cRadius;
				}
			};
			var minCircleRadius=function(d){
				var cRadius = Math.sqrt(fillRatio * cirRadmin/(Math.PI*lambda*R));
				if (cRadius <= 0){
					return 0
				} else {
				return cRadius;
				}
			};
			//domain = value
			//range = disply pixel size = circle radius
			var linearSize = d3.scaleLinear().domain([cirRadmin, cirRadmax]).range([minCircleRadius(cirRadmin),maxCircleRadius(cirRadmax)]);
			
			// create svg for circle legend
			var legendsvg = d3.select("#circleLegend")
					.append('svg')
					.attr('width', legwidth/3)
					.attr("height", 125);

			// show circle legend with color match with the symbol from the map
				legendsvg.append("g")
				  .attr("class", "legendSize")
				  .attr("transform", "translate(30,40)")
				  .style("fill", "rgba(0, 0, 0, 0.1)")
				  .style("opacity", .65)
				  .style("stroke", "black")
				  .style("stroke-width", "1px");
			//}
			// legend title
				var crmin = cirRadmin
				var crmax = cirRadmax
				var cr1 = Math.trunc((((cirRadmax-cirRadmin)/10)*2.5)+cirRadmin)
				var cr2 = Math.trunc((((cirRadmax-cirRadmin)/10)*5)+cirRadmin)
				var cr3 = Math.trunc((((cirRadmax-cirRadmin)/10)*7.5)+cirRadmin)
				var crvals = [cr1,cr2,cr3,crmax];

				function legstring(val){
					if(val >= 1000){
						return val.toString().slice(0,-3) + 'K';
					} else {
						return val.toString();
					}
				}
				var crlbls = crvals.map(x => legstring(x));

				legendsvg.append("text")
				  .attr("x", 15)
				  .attr("y", 6)
				  .attr("dy", ".35em")
				  .style("text-align", "left")
				  .text(theme.circleLegendTitle)
			// legend size and label
				var legendSize = d3.legendSize()
				  .scale(linearSize)
				  .shape('circle')
				  .shapePadding(20)
				  .labelOffset(15)
				  .orient('horizontal')
				// truncate to only show integer, added comma in every three digits
				// label = calculate the values between minimum and maximum values
				// formular = (((Maximum - Minimum)/10)*7.5) + Minimum
				  .cells(crvals)
				  .labels(crlbls);
				
				// call function to draw legend in svg
				legendsvg.select(".legendSize")
					.call(legendSize)
			}
        }
    
	// smooth zoom
	function smoothZoom(toDataSource,toFilter){
		if(toFilter==undefined){toFilter = dataSourceFilter;};
		toDataSource.dataFunc.then(function(the_data_obj){
			// if a filter is set, make sure there is data returned by filter
			// if on cartogram, first toggle back to map
			if(oncartogram){
				busy = true;
				toggle_map(750,function(){
					loadData(toDataSource.dataSourceName, toFilter).then(function(){								
						handleDataLoaded(transition=true).then(function(){
							if(cartogramFeatures != null){
								toggle_map(750);
								busy = false;
							} else {
								busy = false;
							};
						});
					});
				});
			} else {
				loadData(toDataSource.dataSourceName, toFilter)
				.then(function(){
					handleDataLoaded(transition=true);
				})
				.catch(error => {});
			}
		})
	};
    
	// zoom to child 
    function zoomToChild(feat){
		if(data_transitioning == false){
			touring=false;
			// obtain path function for all features
			var match = dataSources.find(v => v.dataSourceName == dataSource.dataChildName);			
			if(match){
				reset();
				smoothZoom(match);
			};      
		}
	}
	
	function zoomToParent(){
		if(data_transitioning == false){
			var match = dataSources.find(v => v.dataSourceName == dataSource.dataParentName);			
			dataSourceFilter=null;
			if(match){
				smoothZoom(match);
			};      
		}
	}
	
	
	// show information when user selects or mouses over a feature	
	function showFeatureInfo(d, showInteractiveElements=true){		
		// get feature info
		var showHTML = featureInfoHTML(d);
		// add interactive elements (i.e. zoom button)		
		if(dataSource.dataChildName != null){
			dataSourceFilter = dataSource.getChildFilter(d);
			if(dataSource.filterValid(dataSourceFilter)){
				//showHTML += "<div style='float: left;'>";
				if(showInteractiveElements){
					// button to show child data source	
					showHTML += "<div style='display: table; width: 100%;'>";
					showHTML += "<div style = 'display: table-cell; vertical-align: middle;'>"
					showHTML += "<button id='zoomDown' class='big_button' data-tooltip-position='bottom' data-tooltip='Zoom In' style='display:inline-block;'>&#10133;</button>";
					showHTML += "</div>";
					showHTML += "<div style = 'display: table-cell; vertical-align: middle; white-space: nowrap;'>";
					showHTML += "Zoom to " + dataSource.getLabel(d) + "</i>";
					showHTML += "</div></div>";
				} else {
					// hint that button exists
					showHTML += "<i>&lt;click for zoom button&gt;</i>";
				};
				//showHTML += "</div>"
			}
		}
		// determine if tooltip will go above or below cursor
		d3.select('#tooltip')
			.style('display','block')
			.html(showHTML)
			.raise();
		// add event listeners to interactive elements
		
		if(showInteractiveElements){
			if(dataSource.dataChildName != null){
				if(dataSource.filterValid(dataSourceFilter)){
					dataSourceFilter = dataSource.getChildFilter(d);
					document.getElementById('zoomDown').addEventListener("click",function(){zoomToChild(d)});
				};
			}
		}
		
		if(d3.event != null){
			if(d3.event.pageY < window.innerHeight/3){
				d3.select('#tooltip')
					.style('left',(d3.event.pageX+10) + 'px')
					.style('top',(d3.event.pageY+10) + 'px')
					.style('bottom',null);		
			} else {			
				d3.select('#tooltip')
					.style('left',(d3.event.pageX+10) + 'px')
					.style('bottom',(window.innerHeight-d3.event.pageY) + 'px')
					.style('top',null);		
			}
		}
	}




	// processes user click on a specific district
	function feature_click(d,i) {
//		if(d3.event != null){
//			d3.event.stopPropagation();
//		}
	  // d is the geometry object
	  // if user clicked on active feature, reset map
	  if (active_feature === d){return reset()};
	  // otherwise, set all features on both maps to inactive
	  districtPaths.selectAll(".active").classed("active", false);
	  // set user-clicked feature on both maps to active
	  d3.select(districtPaths.node().children[i]).
		classed("active", active = d);
	  d3.event.stopPropagation();
	  // record that we have an active feature
	  active_feature = d;
	  showFeatureInfo(d, true);
	}

	function feature_mouseover(d,i){
		if (active_feature == null){
			showFeatureInfo(d, false);
		}
	}

	function feature_mouseout(d,i){	
		if (active_feature == null){
			d3.select('#tooltip').style('display','none');
		}
	}

	// unselect any selected features
	function reset() {
		districtPaths.selectAll(".active").classed("active", active = false);
		active_feature = null;
		districtPaths.transition().duration(750).attr("transform", "");
		d3.select('#tooltip').style('display','none');
	}

	function loadTooltips(){
		// load tooltips
		d3.select('body').
			append('div')
			.attr('id','tooltip')
			.style('position','absolute')
			.style('opacity',1)
			.style('padding','3px')
			.style('user-select','none')
			.style('stroke-alignment','inner');
	}

	// keyboard shortcuts
	function handlekeydown(e){	
		if(e.key=="p" || e.key=="P"){
			// switch to population map
			if(oncartogram==false){
				toggle_map(1500,function(){return false;});
				document.getElementById("carttoggle").checked=true;
			};
		}
		if(e.key=="l" || e.key=="L"){
			// switch to land map
			if(oncartogram==true){
				toggle_map(1500,function(){return false;});
				document.getElementById("carttoggle").checked=false;
			};
		}
		if(e.key=="t" || e.key=="T"){
			// set or remove focus for theme selector
			var selbox = document.getElementById("themeSelector");
			if(selbox === document.activeElement){
				selbox.blur();
			} else {
				selbox.focus();
			}
		}
		if(e.keyCode==37){
			if(document.activeElement === document.getElementById("themeSelector")){
			} else {
				// move back one time step
				curval = slider.value();
				if (curval > 0){
					moving = true;
					slider.value(curval-1);
					moving = false;
				}
			}
		}
		if(e.keyCode==39){
			if(document.activeElement === document.getElementById("themeSelector")){
			} else {
				// move forward one time step
				curval = slider.value();
				if (curval < maxDateID){
					moving = true;
					slider.value(curval+1);
					moving = false;
				}
			}
		}
	}


    function changeDateRange(callerLabel='code',defaultRange=60) {		
		// updates value, min & max of each date picker to valid values
		//   make sure slider value is within range of date pickerStart
		//   if called by user, updates legend color and size ranges 

		prioritizeEndDate=true
		// get first and last dates of data source in YMD format
		dataStart = mdyToYmd(dataSource.dates[0]);
		dataEnd = mdyToYmd(dataSource.dates[dataSource.dates.length-1]);

		// shortcut variables to start and end date picker objects
		var startPicker = document.getElementById("startDatePicker");
		var endPicker = document.getElementById("endDatePicker");

		// current values for start and end dates
		var pickerStart = startPicker.value; 
		var pickerEnd = endPicker.value;

		// determine if date for start date picker needs to be updated
		if(pickerStart==''){
			// if null, set to default time before end date
			newStartID = dataSource.dates.length-defaultRange;
			if(newStartID < 0){newStartID = 0;}
			pickerStart = mdyToYmd(dataSource.dates[newStartID]);
		} 
		if(compareDates(pickerStart,dataStart)==-1){pickerStart = dataStart;}  // ensure not before data start
		if(compareDates(pickerStart,dataEnd) == 1){pickerStart = dataEnd;} // ensure not after data end
		
		// update determine if date for end date picker needs to be updated
		if(pickerEnd==''){pickerEnd = dataEnd;} // if null, set to data end
		if(compareDates(pickerStart,dataStart)==-1){pickerEnd = dataStart;} // ensure not before data start
		if(compareDates(pickerStart,dataEnd) == 1){pickerEnd = dataEnd;} // ensure not after data end
		// ensure not after end picker date
		if (compareDates(pickerStart,pickerEnd) == 1){
			// if not, we'll update the one that is not prioritized
			if (prioritizeEndDate){
				pickerStart = pickerEnd;
			} else {
				pickerEnd = pickerStart
			}
		}
		
		// set date picker values and min/max ranges		
		startPicker.value = pickerStart;
		startPicker.min = dataStart;
		startPicker.max = pickerEnd;
		
		endPicker.value = pickerEnd;
		endPicker.min = pickerStart;
		endPicker.max = dataEnd;
		
		// update current date
		if(curDate != null){
			if(compareDates(mdyToYmd(curDate),startPicker.value)==-1){curDate = ymdToMdy(startPicker.value);}
			if(compareDates(mdyToYmd(curDate),endPicker.value)==1){curDate = ymdToMdy(endPicker.value);}
		}
		// when finished, reload the slider and map (if called by user)
		// 
		if (theme != undefined){
			if(callerLabel=='user'){
				loadSlider(curDate).then(function(){
					loadChoroplethLegend();
					updateMap(slider_update_duration,null,'changeDateRange')
				});
			} else {
				loadSlider();
			}			
		}
    }
    
    function resetDateRange(days=-1) {
        
		// THIS DOESN'T WORK:
		//document.getElementById('startDatePicker').setAttribute("value",mdyToYmd(dataSource.dates[0]));
		//document.getElementById('endDatePicker').setAttribute("value",mdyToYmd(dataSource.dates[dataSource.dates.length-1]));
		// THIS WORKS:
		
		var endID = dataSource.dates.length-1;
		var startID = 0;
		if(days != -1){
			startID = endID - days;
			if(startID < 0){startID = 0;}
		} 
		document.getElementById('startDatePicker').value = mdyToYmd(dataSource.dates[startID]);
		document.getElementById('endDatePicker').value = mdyToYmd(dataSource.dates[endID]);
        loadSlider().then(function(){ 
			updateMap(slider_update_duration,null,'resetDateRange')
		});
        playButton.text("►");
        moving = false;
        clearInterval(timer);
        slider.value(maxDateID);
    }
    
  	var loadSlider=function(targetDate=null){return new Promise(function(resolve, reject){
        // remove existing slider
		if (slider_svg != null){
			slider_svg.remove();
		}
		// get available width
		var slider_width = $("#options_panel").width()-60;
		if(slider_width < 100){slider_width=100;};

        /* Finding index of startDate and endDate selected by user*/
		var minDate = document.getElementById('startDatePicker').value
        var minDateID = dataSource.dates.indexOf(ymdToMdy(minDate))
		var maxDate = document.getElementById('endDatePicker').value
        var maxDateID = dataSource.dates.indexOf(ymdToMdy(maxDate))
		
        if (minDateID == -1){
            minDateID = 0;
        }
        if (maxDateID == -1){
            maxDateID = dataSource.dates.length-1
        }
        if (minDateID >= maxDateID){
            minDateID = maxDateID
        }
		
       var dtSlice = dataSource.dates.slice(minDateID,maxDateID);
        
		var secretCode="Yes please show month!";
		function dateString(sliderID, showMonthParam){
			sliderID = Math.round(sliderID);
			var date = new Date(dataSource.dates[sliderID]);
			var year = date.getFullYear();
			var month = date.getMonth()+1;
			var day = date.getDate();
			var r = day;
			// show Month if we're on the first day of the month
			if (sliderID==0 || date.getDate() < 32 || showMonthParam==secretCode){
				r = monthString(month) + " " + day;
			}
			return r;
		}
		slider_svg = d3.select('#slider')
			.attr('align','center')
			.append('svg');
		textData=[0];

		// load slider
		
		// console.log("LOAD SLIDER: " + maxDateID);
		var circlepath ="M -7,0 A 7,7 0,0,1 7,0 A 7,7 180,0,1 -7,0 z"
		var tick_ids = tickDateIds(dataSource.dates,10,minDateID,maxDateID);
		slider = d3
			.sliderHorizontal()
			.min(minDateID)
			.max(maxDateID)
			.tickValues(tick_ids)
			.width(slider_width - 50) // slider should be smaller than the svg
			.fill('#CA6')
			.handle(d3.symbol()
			  .type(d3.symbolCircle)
			  .size(500))
			.tickFormat(dateString)		
			.displayValue(true)
			.on('onchange', function(val) {
				//slider.displayValue("Hi there!");
				//d3.select('#value').text("???");
				// console.log("slider change: " + val);
				curDate = dataSource.dates[Math.round(val)];
				updateMap(delay*3,null,'sliderChange',updateR=false);
			});
		slider_svg
			.attr('width', slider_width)
			.attr('height', 75)
			.attr('tabindex',0)
			.append('g')
			.attr('transform', 'translate(30,30)')
			.call(slider);
        
		// define current date
		var oldDate = curDate;
		 // change this to get the nearest date
		if(oldDate != null && curDate != null){
			// get the nearest date in the new data source to the old date
			var nearestDate = dataSource.dates.reduce((a,b) => {
				return Math.abs(Date.parse(b)-Date.parse(oldDate)) , Math.abs(Date.parse(a)-Date.parse(oldDate)) ? b : a;
			});
			// console.log("handleDataLoaded : " + curDate);
			curDate = nearestDate
		} else {
			// console.log("handleDataLoaded : " + curDate);
			curDate=dataSource.dates[dataSource.dates.length-1];
		}

		if(targetDate != null){
			
			var targetID = dataSource.dates.indexOf(targetDate);
			if(compareDates(mdyToYmd(targetDate),mdyToYmd(dataSource.dates[minDateID]))==-1){targetID = minDateID;}
			if(compareDates(mdyToYmd(targetDate),mdyToYmd(dataSource.dates[maxDateID]))==1){targetID = maxDateID;}
			curDate = dataSource.dates[targetID];
			slider.value(targetID);
		};
		resolve();
	})}

	function handleDataLoaded(transition=false){
		return new Promise(function(resolve,reject){
			// loads new data into the map and updates the slider
			// update the slider
			// report current dataset
			if(dataSource.dataParentName==null){
				document.getElementById("zoomlabel").style.display="none";
				document.getElementById("zoomcontrol").style.display="none";
			} else {
				document.getElementById("zoomlabel").style.display='block';
				document.getElementById("zoomlabel").innerHTML="zoomed to: " + dataSourceFilter;
				document.getElementById("zoomcontrol").style.display="block";
				document.getElementById("zoomUpLabel").innerHTML = "<i> Zoom out to " + dataSource.dataParentName + "</i>";
			};
			// show filter options
			if(dataSource.dataChildName != null){
				showFilterSelector();
			}

			loadSlider().then(function(){
				// define current date
				var oldDate = curDate;
				 // change this to get the nearest date
				if(oldDate != null && curDate != null){
					// get the nearest date in the new data source to the old date
					var nearestDate = dataSource.dates.reduce((a,b) => {
						return Math.abs(Date.parse(b)-Date.parse(oldDate)) , Math.abs(Date.parse(a)-Date.parse(oldDate)) ? b : a;
					});
					curDate = nearestDate
				} else {
					curDate=dataSource.dates[0];
				}
				// load the map!
				loadMap(baseFeatures,undefined, undefined, transition).then(function(){

					// update date picker min/max values
					changeDateRange();
					loadSlider();
				
					//load new theme if the current theme is not available
					if(themeAvailable(theme,dataSource)==false){loadTheme();};
					
					// resize everything
					resize();
					slider.value(dataSource.dates.indexOf(curDate));
					// resolve promise
					resolve();
				});			
			});	
		})
	};
    
    //var sliderID
    var currentIndex //= sliderID;
    var playButton = d3.select("#play-button");
    var moving = false;
    var looping = false;
    var delay = delayIntervals[2];
    var dots = document.getElementsByClassName("dot");
    var i;

    function updateDotColors() {
        for (i = 0; i < dots.length; i++){ 
			var dotDelay = delayIntervals[i];
			if (dotDelay < delay) {
				dots[i].style.backgroundColor = "#bbb";
			} else if (dotDelay >= delay){
				dots[i].style.backgroundColor = "#004C97";
			}
		}
    }

    function delayDots(n) {
        clearInterval(timer);
        delay = delayIntervals[n];
        if (moving == true) {
            timer = setInterval(step, delay);
            playButton.text("∥");
            moving = true;
        }
            updateDotColors()
    };
    
	function handlePlayButtonClick(){	
		var button = d3.select(playButton);
		if (playButton.text() == "∥") {
		  moving = false;
		  touring = false;
		  busy = false;
		  clearInterval(timer);
		  // timer = 0;
		  playButton.text("►");
		} else { 
		  if (slider.value() == maxDateID) {
			  currentIndex = minDateID;
		  } else {
			currentIndex = slider.value();
		  }
		  playStartID = currentIndex;
		  playEndID = maxDateID;
		  moving = true;
		  timer = setInterval(step, delay);
		  playButton.text("∥"); 
		}
	}
	
    playButton
        .on("click", handlePlayButtonClick);
    
	function step(){
		var startDateID = dataSource.dates.indexOf(ymdToMdy(document.getElementById('startDatePicker').value))
        var endDateID = dataSource.dates.indexOf(ymdToMdy(document.getElementById('endDatePicker').value))
		if(startDateID==-1){startDateID = 0;}
		if(endDateID==-1){endDateID = dataSource.dates.length;}
		
		curDate = dataSource.dates[currentIndex];
		slider.value(currentIndex);
        if (slider.value() == endDateID && looping == true) {
                var pauseStart = setTimeout(function(){
                    currentIndex = startDateID;
                },5000);
              } else {
                currentIndex = currentIndex + 1;
              }
		// stop at end of loop otherwise
        if (currentIndex > maxDateID && looping == false) {
			moving = false;
			currentIndex = defaultPlayStartID;
			clearInterval(timer);
			// timer = 0;
			playButton.text("►");
			// playButton.text("▶");
		} 
	}
    
    var slowerButton = d3.select("#slower-button");
		slowerButton
			.on("click", function() {
			var button = d3.select(this);
			clearInterval(timer);
			var curIndex = delayIntervals.indexOf(delay);
			if (curIndex > 0) {
				delay = delayIntervals[curIndex-1];
			}
			if (moving == true) {
				timer = setInterval(step, delay);
				playButton.text("∥");
				moving = true;
			}
			updateDotColors()
		  });
    
    var fasterButton = d3.select("#faster-button");
		fasterButton
			.on("click", function() {
				var button = d3.select(this);
				clearInterval(timer);
				var curIndex = delayIntervals.indexOf(delay);
                if (curIndex < 4) {
					delay = delayIntervals[curIndex+1];
                }
            if (moving == true) {
				timer = setInterval(step, delay);
				playButton.text("∥");
                moving = true;
            }
                updateDotColors()
			});
    
    
	function handleLoopButtonClick(){
		var button = d3.select(this);
		if (button.text() == "⇥") {
			looping = false;
			button.text("↻")
		} else {
			looping = true;
			button.text("⇥");
		}
	}
	
    var loopButton = d3.select("#loop-button");
        loopButton
            .on("click", handleLoopButtonClick);

	function playTour(){
		// restrict user control
		busy=true;
		touring=true;
		document.getElementById("Faster").click();
		
		setTimeout(function(){
			if(touring){
				document.getElementById("carttoggle").checked=true;
				toggle_map(2000, function(){
					// enter looping mode
					delayDots(3);
					// handleLoopButtonClick();
					// loopButton.text("⇥");
					// start playing animation
					handlePlayButtonClick();
					// give back user control
					busy=false;
					touring=false;
				});
			};
		},5000);
	}

	loadData(document.getElementById("dataSourceSelector").value).then(function(){
		// we're not done yet...
		handlePageLoading()
		//set 3dots
		updateDotColors();
		// load the invisible tooltip div...
		loadTooltips();
		// set defaults, add event listeners
		document.onkeydown=handlekeydown;			
		document.getElementById("carttoggle").addEventListener("change",function(){
			touring=false;
			if(busy == false){toggle_map(1500);};
		});
		document.getElementById("themeSelector").addEventListener("change",function(){
			touring=false;
			if(busy == false){loadTheme();};
		});
		document.getElementById("dataSourceSelector").addEventListener(
			"change",function(){
				touring=false;
				if(busy == false){
					loadData(document.getElementById("dataSourceSelector").value)
						.then(function(){
							handleDataLoaded()
						})
						.catch(error => {});
				};
			}
		);
		document.getElementById('zoomUp').addEventListener("click",function(){
			if(busy == false){zoomToParent();};
		});
		$('themeSelector').on('keydown', function(e){
			if(e.keyCode === 37 || e.keyCode === 39) { //left or right
				e.preventDefault();
				return false;
			}
		});
		
		handleDataLoaded().then(function(){
			// handle default data source
			defaultPlayStartID = dataSource.dates.length-56; // by default play the last 8 weeks
			if(defaultPlayStartID < 0){defaultPlayStartID = 0;};
			setTimeout(function()
				{
					orig_duration = slider_update_duration;
					slider_update_duration = 500;
					slider.value(maxDateID);					
					slider_update_duration = orig_duration;
				},500
			);
			// load additional data sources	
			var newDataSources = [
				dataODWG_Canada_Provinces(),
				dataJHU_USA_Counties(),
				dataJHU_Europe()
			];		
			dataSources=dataSources.concat(newDataSources);
			var additionalDataItemsLoaded=0;		
			for(i=0; i<newDataSources.length; i++){
				newDataSources[i].dataFunc.then(function(){handleAllDataLoaded();});
			}
			function handleAllDataLoaded(){
				additionalDataItemsLoaded += 1;
				if(additionalDataItemsLoaded == newDataSources.length){
					// console.log("ALL DATA LOADED!!!!!!!");
					document.getElementById("messagearea").innerHTML="<p><i>Click on any " + dataSource.districtClassLabel + " for more details.</i></p>"			
					addDataSourcesToSelector(newDataSources);
					// console.log("data sources added...");
					toggle_map();
					// Start default animation tour!
					//playTour();
				}
			}
		});

	});


</script>

</body>
</html>