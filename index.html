<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <link rel="stylesheet" href="d3_map_styles.css"> 
  <title>COVID-19 Rate Map - EIU GIScience Center</title>
  <script src="jquery-3.4.1.js"></script>
  <script src="https://d3js.org/d3.v5.js" charset="utf-8"></script>
  <!--<script src="USA_pop2010.js"></script> -->
  <script src="data/states_covidtracking/data_covidtracking_states.js"></script>
  <script src="d3-simple-slider.min.js"></script>
  <script src="ResizeSensor.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/4.2.2/d3.min.js"></script>
  <script src="legend_susielu.js"></script>
  <script src="utils.js"></script>
  <script src="themes/theme_cases_cumulative.js"></script>
  <script src="themes/theme_new_cases.js"></script>
  <script src="themes/theme_positive_test_ratio.js"></script>
  <script src="themes/theme_new_positive_test_ratio.js"></script>
  <script src="themes/theme_case_mortality.js"></script>
  <script src="themes/theme_case_mortality_7day_lag.js"></script>


</head>

<body>
	<div id="opening_screen">
		<div id="maptop" style="text-align: center;margin-top:0ex; margin-bottom: 0ex;" >	
			<h3  style="margin-top:0ex; margin-bottom: 0ex;">Covid-19 Open Visualization (COViz) Toolkit </h3>
		</div>
						
		<div id="map"></div>
		<div id="mapbottom">
			<div id="slider" style="align: center; float: left;"></div>							
			<div id="legend" style="align: center; float: right;"></div>								
		</div>
		<div id="options" style="display: table; overflow: hidden; min-height: 100%;">
			<div style="display: table-cell; vertical-align: middle;">
				<table style="border:none; width: 90%; border-spacing: 15px;">
					<tr>
						<td>
							Data Source:
						</td>
						<td>
							<select class="select-css" id="dataSourceSelector">
							</select>			
						</td>
					</tr>
					<tr>
						<td>
							Map Theme:
						</td>
						<td>
							<select class="select-css" id="themeSelector">
							</select>
						</td>
					</tr>
					<tr>
						<td colspan=2 id="brief_description">
						</td>
					</tr>

					<tr>
						<td>
							Map Type:
						</td>
						<td>
							<span>
								<u>L</u>and
								<label class = "switch">
								<input id="carttoggle" type="checkbox"">
								<span class="slider round"></span>
								</label>
								<u>P</u>opulation
							</span>					
						</td>
					</tr>
				</table>		  
			</div>
		</div>
	</div>
	<div id="below_screen">
	<H3> About </H3>
				<p>This web page provides a template for mapping information relevant to COVID-19, with the 
				goal of supporting informed decision-making by individuals and organizations. 
				Standardized map themes are being developed to communicate overall disease burden (case, 
				hospitalization and mortality rates), resource and testing sufficiency, and effects of 
				social distancing policy. All map themes will follow sound cartographic principles, and 
				timelines, animation and interactive components will allow exploration of past and current 
				trajectories of each variable. </p>
				
				<br>
				This is an open-source project. You are free to download, customize, modify data sources and 
				incorporate into your own website, with the caveat that no warranty is provided. 
				<br><br>
				Keyboard shortcuts (these work inconsistently at the moment):<BR>
				<table style="border: none">
					<tr>
						<td>T</td>
						<td>Place focus on the theme selector</td>
					</tr>
					<tr>
						<td>&larr; &rarr;</td>
						<td>Move along timeline (when focus off var. sel.)</td>
					</tr>
					<tr>
						<td>L,P</td>
						<td>Toggle between land and population map types</td>
					</tr>
				</table>
				<p><i>(click on any state for data values)</i></p>
				<br>
				This website is being developed by the <a href="https://www.eiu.edu/gisci/">EIU GIScience Center</a>. 
				Data comes from <a href="https://covidtracking.com/">covidtracking.com</a>.  
				Latest project updates can be found on our <a href = "https://github.com/EIU-GIScience-Center/covid19map">github repository</a>.
				This is a work in progress. Feel free to send <a href="mailto: bjkronenfeld@eiu.edu">comments or feedback</a>.
				<br><br>
	</div>
<script defer>
	// load default dataset
	var cr10 = Math.cbrt(10);
	var base;
	var cartogram;
	var active_feature = null;
	var active;
	var oncartogram = false;
	var dates;
	var districts;
	var dateDistrictData;
	var curDate = null;
	var slider;
	var slider_svg;
	var slider_update_duration = 750;
	// map objects
	var mapsvg; // svg containing map
	var statepaths; // svg group containing paths for each state
	var circles; // svg group containing smaller circle for each state
	// map theme functions and values
	var choroplethValue; // function to get value given feature, date
	var tooltipText; // function to get text for given value, given feature, date
	var choroplethColorScale; // scale function for legend (doesn't include white for zero)
	var lowValColor = null;
	var highValColor = null;
	var lowVal;
	var highVal;
	var choroplethCellsAndLabels; // function returning [C,L] : legend symbol cells and corresponding labels;
	var choroplethLegTitle; // string text for legend title
	var circleRadius; // function to determine size of small circles
	var circleFill='#f47'; // fill color
	var circlestroke='#a05'; // stroke color

	// array of themes
	// each theme should be defined in a separate file; see theme_new_cases.js for a template
	var themes = [
		themeCasesCumulative,
		themeNewCases,
		themePositiveTestRatio,
		themeNewPositiveTestRatio,
		themeCaseMortality, 
		themeCaseMortality_7dayLag
    ]

	// array of data sources
	// each data source should be defined in a separate file; see data_covidtracking_states.js for a template
	var dataSources = [
		dataCovidTracking_states
	]

	// Add modules to the selector
	const themeSelector = document.getElementById("themeSelector");
	for (i=0; i<themes.length; ++i) {
		const option = document.createElement("option");
		option.text=themes[i].themeName;
		themeSelector.add(option);
    }

	// Add datasets to the selector
	const dataSourceSelector = document.getElementById("dataSourceSelector");
	for (i=0; i<dataSources.length; ++i) {
		const option = document.createElement("option");
		option.text=dataSources[i].dataSourceName;
		dataSourceSelector.add(option);
    }

	function truncateCellsAndLabels(cells,labels, lowVal, highVal){
		// get indices of highest cell below lowVal, and lowest cell above highVal
		var lowIndex=0;
		var highIndex=cells.length-1;
		var gotHigh = false;
		for(i=0;i<cells.length;i++){
			if (cells[i] < lowVal){lowIndex = i;}
			if(gotHigh == false){
				if(cells[i] > highVal){
					highIndex = i; 
					gotHigh = true;
				}
			}
		}
		// slice out the corresponding section of the cells and labels
		cells = cells.slice(lowIndex, highIndex + 1);
		labels = labels.slice(lowIndex, highIndex + 1);
		return [cells,labels];
	}

	function loadTheme(){
		// determine the new map theme
		var themeName = document.getElementById("themeSelector").value;		
		// Look for the theme in our theme modules
		const match = themes.find(v => v.themeName == themeName)
		if (match) {
			briefDescription = match.briefDescription;
			choroplethValue = match.choroplethValueFcn;
			tooltipText = match.tooltipTextFcn;
			var choroplethColorInterpolator = match.choroplethColorInterpolator;
			choroplethCells = match.choroplethCells;
			choroplethLabels = match.choroplethLabels;
			choroplethLegTitle = match.choroplethLegendTitle;
			circleRadius = match.circleRadiusFcn;
			circleFill = match.circleFill;
			circlestroke = match.circleStroke;
			choroplethValueScale = match.choroplethValueScale;
			var invertColorScale = match.invertColorScale;
			// show the description of the theme
			document.getElementById("brief_description").innerHTML ="<i>" + briefDescription + "</i>";
			// calculate true legend/color/size scales based on theme parameters
			if(invertColorScale){
				lowValColor = choroplethColorInterpolator(1);
				highValColor = choroplethColorInterpolator(0);
			} else {
				lowValColor = choroplethColorInterpolator(0);
				highValColor = choroplethColorInterpolator(1);
			}
			
			// following should be modified to utilize Jason's function
			if(themeName == themeCasesCumulative.themeName){
				lowVal= 300; 
				highVal= 16000;
			} else if (themeName == themeNewCases.themeName){
				lowVal= 10; 
				highVal= 1600;
			} else if (themeName == themePositiveTestRatio.themeName){
				lowVal= 1; 
				highVal= 50;
			}  else if (themeName == themeNewPositiveTestRatio.themeName){
				lowVal= 1; 
				highVal= 50;
			} else if (themeName == themeCaseMortality.themeName){
				lowVal= 0.5; 
				highVal= 10;
			} else if (themeName == themeCaseMortality_7dayLag.themeName){
				lowVal= 0.5; 
				highVal= 10;
			}
			
			
			// truncate legend cells and labels to low and high values
			[choroplethCells, choroplethLabels]=truncateCellsAndLabels(choroplethCells,choroplethLabels,lowVal, highVal);

			var unitIntervalScale = d3.scaleLinear()
				.domain([choroplethValueScale(lowVal), choroplethValueScale(highVal)]);
			if(invertColorScale){
				choroplethColorScale =d3.scaleSequential(function(d){
					return choroplethColorInterpolator(1-unitIntervalScale(choroplethValueScale(d)));
				});
			} else {
				choroplethColorScale =d3.scaleSequential(function(d){
					return choroplethColorInterpolator(unitIntervalScale(choroplethValueScale(d)));
				});
			
			}

		}
		// update the map and legend
		updateMap(curDate);
		loadLegend();
	}

  	var loadData=function(){
		return new Promise(
			function(resolve, reject){
				// determine new data source
				var dataSource = document.getElementById("dataSourceSelector").value;		
				// find matching data source object
				const match = dataSources.find(v => v.dataSourceName == dataSource);
				if(match){
					data_func = match.dataFunc;
					Promise.resolve(data_func).then(function(data_obj){
						base = data_obj.baseFeatures;
						cartogram = data_obj.cartogramFeatures;
						dates = data_obj.dates;
						districtIDs = data_obj.districtIDs;
						variableNames = data_obj.variableNames;
						dateDistrictData = data_obj.dateDistrictData;
						getID = data_obj.getID;
						getPopulation = data_obj.getPopulation;
						var getValue_raw = data_obj.getValue;
						getValue = function(feat, date, varName, perMillion=false, getIncrease = false){
							var featID = getID(feat);
							var val = getValue_raw(dateDistrictData,featID,date,varName);
							if(perMillion){val = val*1000000/getPopulation(feat);}
							if(getIncrease){
								var yesterday = previousDate(date, dates);
								if (yesterday != null){
									var yesterdayVal = getValue(feat,yesterday,varName,perMillion,false);				
									val = val-yesterdayVal
								}
							}		
							return val;
						}
					resolve()
					})
				}
			}
		)
	};

	function extendColorScale(initScale,inVal){
		if (lowValColor != null){
			if (inVal <= lowVal){
				return lowValColor;
			} 
		}
		if (highValColor != null){
			if (inVal >= highVal){
				return highValColor;
			}
		}
		return initScale(inVal);
	}

	function choroplethColor(feat,date){
		// assign a color based on rate per million
		var featval =choroplethValue(feat,date);
		return extendColorScale(choroplethColorScale,featval);
	}			
	
	function prjXFunction(scale,trans){
		var f = function(x){		
			return x*scale+trans;
		}
		return f;
	}

	function prjYFunction(scale,trans){
		// Why is this formula different for y than for x?? 
		// I have no idea, something to do with flipped coordinates... anyway this just works.
		var f = function(y){		
			return trans-y*scale;
		}
		return f;
	}

	
	function fitProjection(data, box, center) {
		// get the bounding box for the data - might be more efficient approaches
		var left = Infinity,
			bottom = Infinity,
			right = -Infinity,
			top = -Infinity;
		// get "projection"
		var projection = d3.geoIdentity().reflectY(true);
		// reset projection
		projection
			.scale(1)
			.translate([0, 0]);
		data.features.forEach(function(feature) {
			coords = feature.geometry.coordinates[0][0];
			var minX = d3.min(coords, function(array) {return array[0];});
			var maxX = d3.max(coords, function(array) {return array[0];});
			var minY = d3.min(coords, function(array) {return array[1];});
			var maxY = d3.max(coords, function(array) {return array[1];});
			if (minX < left) {left = minX;};
			if (maxX > right) {right = maxX;};
			if (minY < bottom) {bottom = minY;};
			if (maxY > top) {top = maxY;};
			
			});
		var temp = bottom;
		bottom = top;
		top =  temp;
		
		// project the bounding box, find aspect ratio
		function width(bb) {
			return (bb[1][0] - bb[0][0])
			}

		function height(bb) {
			return (bb[1][1] - bb[0][1]);
			}
		  
		function aspect(bb) {
			return width(bb) / height(bb);
			}
		var startbox = [[left, top],  [right, bottom]],
			a1 = aspect(startbox),
			a2 = aspect(box),
			widthDetermined = a1 > a2,
			scale = widthDetermined ?
			// scales determined by width & height
			width(box) / width(startbox) :
			height(box) / height(startbox),
			// set x & y translations
			transX = box[0][0] - startbox[0][0] * scale,
			transY = box[0][1] - startbox[0][1] * scale;
		// center if requested
		if (center) {
			transY = transY - (transY + startbox[1][1] * scale - box[1][1])/2;
			transX = transX - (transX + startbox[1][0] * scale - box[1][0])/2;
		}
		
		// if using real projection (as opposed to geoIdentity), 
		// set precision to zero to prevent D3 from adding points through "adaptive sampling"
		return [projection.scale(scale).translate([transX, transY]),scale,transX,transY];
	}	

	// switches map features to the given features
	function switchMapCartogram(divid, newFeatSet, fromdata,milliseconds,callback){
		var ele = document.getElementById(divid); // Do not use #
		var width = ele.clientWidth;
		var height = ele.clientHeight;
		divid = '#' + divid;
		var prj,scale,transX,transY;
		[prj,prjscale,transX,transY]=fitProjection(newFeatSet, [[0, 0],  [width, height]], true)
		var path = d3.geoPath().projection(prj);
		
		var bounds = path.bounds(newFeatSet), 
			dx = bounds[1][0] - bounds[0][0],
			dy = bounds[1][1] - bounds[0][1],
			x = (bounds[0][0] + bounds[1][0]) / 2,
			y = (bounds[0][1] + bounds[1][1]) / 2,
			boundsscale = .9 / Math.max(dx / width, dy / height),
			translate = [width / 2 - boundsscale * x, height / 2 - boundsscale * y];

		
		m.selectAll('path')
			.transition()
			.attr("d",function(d,i){return path(newFeatSet.features[i]);})
			.attr("transform", "translate(" + translate + ")scale(" + boundsscale + ")")
			.duration(milliseconds)
			.on("end",callback);	
		
		mapsvg.selectAll('circle')
			.transition()
			.attr("cx", function(d,i){
				var thisFeat = newFeatSet.features[i];				
				var prjX = prjXFunction(prjscale,transX); 
				return prjX(centroid(thisFeat)[0]);
			})
			.attr("cy", function(d,i){
				var thisFeat = newFeatSet.features[i];			
				var prjY = prjYFunction(prjscale,transY); 
				return prjY(centroid(thisFeat)[1]);
			})
			.attr("transform", "translate(" + translate + ")scale(" + boundsscale + ")")
			.duration(milliseconds);
	}

	// toggles between the current base map and cartogram
	function toggle_map(milliseconds=1500, callback){
		if (oncartogram){
			switchMapCartogram('map', base, cartogram, milliseconds, callback);
		} else {
			if(cartogram != null){
				switchMapCartogram('map', cartogram, base, milliseconds, callback);
			}
		}
		oncartogram = !oncartogram;
	}


	// handle resizing
	new ResizeSensor(jQuery('#map'), function(){ 
		// rearrange divs
		//loadLegend();
		//loadSlider();
		// make sure theme is updated
		loadTheme();
		// update map
		if (curDate != null){
			if(oncartogram==true){
				m = loadMap(cartogram);
			} else {
				m = loadMap(base);
			}
			updateMap(curDate);
			loadSlider();
		}
	});		

	function featureInfoHTML(feature){
		if(feature != null){
			// show data for selected feature
			// population data is from feature itself
			var pop = feature.properties.POP_2010
			// remaining data is from "dateDistrictData" object, lookup by date and state
			var stateAbbrev = feature.properties.ABBREV;
			let [year, month, day] = parseDate(curDate);
			showHTML = "<B>" + feature.properties.STATE_NAME + " (" + monthString(month) + " " + day + ")</B><BR>";
			showHTML += tooltipText(feature,curDate);
			return showHTML;
		} else {
			return "";
		}
	}


	function loadMap(featdata,categories, category){
		divid='map';
		var ele = document.getElementById(divid); // Do not use #
		var width = ele.clientWidth;
		var height = ele.clientHeight;
		
		divid = '#' + divid;
		d3.select(divid).selectAll('svg').remove();			
		mapsvg = d3.select(divid)
				.append('svg')
				.attr('width',width)
				.attr('height',height)
				.on('click',reset);
		statepaths = mapsvg.append('g');
		var prj,scale,transX,transY;

		[prj,prjscale,transX,transY]=fitProjection(featdata, [[0, 0],  [width, height]], true)
		var path = d3.geoPath()
			.projection(prj);
		var bounds = path.bounds(featdata), 
			dx = bounds[1][0] - bounds[0][0],
			dy = bounds[1][1] - bounds[0][1],
			x = (bounds[0][0] + bounds[1][0]) / 2,
			y = (bounds[0][1] + bounds[1][1]) / 2,
			boundsscale = .9 / Math.max(dx / width, dy / height),
			translate = [width / 2 - boundsscale * x, height / 2 - boundsscale * y];
		statepaths.selectAll('path')
			.data(featdata.features)
			.enter()
			.append('path')
			.attr('d',path)
			.attr("class","feature")
			.attr("stroke", "#EEE")
			.attr("stroke-width", "1px")
			.attr("fill",function(d){return choroplethColor(d, curDate);})
			.attr("transform", "translate(" + translate + ")scale(" + boundsscale + ")")
			.on("click",feature_click)
			.on("mouseover",feature_mouseover)
			.on("mouseout",feature_mouseout);	

		circles = mapsvg.append('g');

		circles.selectAll('circle')
			.data(featdata.features)
			.enter()
			.append('circle')
			.attr("cx", function(d){
				var prjX = prjXFunction(prjscale,transX); 
				return prjX(centroid(d)[0]);
			})
			.attr("cy", function(d){
				var prjY = prjYFunction(prjscale,transY); 
				return prjY(centroid(d)[1]);
			})
			.attr("transform", "translate(" + translate + ")scale(" + boundsscale + ")")
			.style('fill',circleFill)
			.style('stroke',circlestroke)
			.style('stroke-width',1)
			.style('opacity',0.5)
			.on("click",feature_click)
			.on("mouseover",feature_mouseover)
			.on("mouseout",feature_mouseout);			
		statepaths.exit().remove();
		return statepaths;
	}

	// updates the map data to the given date 
	function updateMap(date, delay=0,duration=750, callback){
		if(curDate != null){
			statepaths.selectAll('path')
				.transition()
				.attr("fill",function(d){return choroplethColor(d, date);})
				.delay(delay)
				.duration(duration)
				.on('end',callback);
			circles.selectAll('circle')
				.transition()
				.attr('r',function(d){return circleRadius(d,date);})
				.style('fill',circleFill)
				.style('stroke',circlestroke)
				.delay(delay)
				.duration(duration);
			if(active_feature != null){showFeatureInfo(active_feature);}
		}
	}

	function loadLegend(){
		// get available width
		var viewportwidth = $(window).width();
		var legwidth = 0.45*(viewportwidth);
		if(legwidth < 100){legwidth=100;};	
		// remove any existing legend
		d3.select("#legend").selectAll('svg').remove();			
		// create svg for new legend
		var legendsvg = d3.select("#legend")
			.attr('align','center')
			.append('svg')
			.attr('width',legwidth)
			.attr('height',60);		
		legendsvg.append("g")
		  .attr("class", "legendSequential")
		  .attr("transform", "translate(20,20)");
		// create legend
		var numCells = choroplethCells.length;
		var legendSequential = d3.legendColor()
			.shapeWidth((legwidth-30)/numCells)
			.title(choroplethLegTitle)
			.cells(choroplethCells)
			.orient("horizontal")
			.labels(choroplethLabels)
			.scale(choroplethColorScale)
			.shapePadding(-1)
			.shapeHeight(15)
			.labelOffset(6); 
		// call function to draw legend in svg
		legendsvg.select(".legendSequential")
		  .call(legendSequential);
	}

	// show information when user selects or mouses over a feature	
	function showFeatureInfo(d){		
		// determine if tooltip will go above or below cursor
		d3.select('#tooltip')
			.style('opacity',1)
			.html(featureInfoHTML(d))
			.raise();
		if(d3.event != null){
			if(d3.event.pageY < window.innerHeight/3){
				d3.select('#tooltip')
					.style('left',(d3.event.pageX+10) + 'px')
					.style('top',(d3.event.pageY+10) + 'px')
					.style('bottom',null);		
			} else {			
				d3.select('#tooltip')
					.style('left',(d3.event.pageX+10) + 'px')
					.style('bottom',(window.innerHeight-d3.event.pageY) + 'px')
					.style('top',null);		
			}
		}
	}

	// processes user click on a specific district
	function feature_click(d,i) {
	  // d is the geometry object
	  // if user clicked on active feature, reset map
	  if (active_feature === d){return reset()};
	  // otherwise, set all features on both maps to inactive
	  m.selectAll(".active").classed("active", false);
	  // set user-clicked feature on both maps to active
	  d3.select(m.node().children[i]).
		classed("active", active = d);
	  d3.event.stopPropagation();
	  // record that we have an active feature
	  active_feature = d;
	  showFeatureInfo(d);
	}

	function feature_mouseover(d,i){
		if (active_feature == null){
			showFeatureInfo(d);
		}
	}

	function feature_mouseout(d,i){
		if (active_feature == null){
			d3.select('#tooltip').style('opacity',0);
		}
	}

	// unselect any selected features
	function reset() {
			m.selectAll(".active").classed("active", active = false);
			active_feature = null;
			m.transition().duration(750).attr("transform", "");
			d3.select('#tooltip').style('opacity',0);
	}

	function loadTooltips(){
		// load tooltips
		d3.select('body').
			append('div')
			.attr('id','tooltip')
			.style('position','absolute')
			.style('opacity',0)
			.style('padding','3px')
			.style('user-select','none')
			.style('stroke-alignment','inner');
	}

	// keyboard shortcuts
	function handlekeydown(e){
		if(e.key=="p" || e.key=="P"){
			// switch to population map
			if(oncartogram==false){
				toggle_map(1500,function(){return false;});
				document.getElementById("carttoggle").checked=true;
			};
		}
		if(e.key=="l" || e.key=="L"){
			// switch to land map
			if(oncartogram==true){
				toggle_map(1500,function(){return false;});
				document.getElementById("carttoggle").checked=false;
			};
		}

		if(e.key=="t" || e.key=="T"){
			// set or remove focus for theme selector
			var selbox = document.getElementById("themeSelector");
			if(selbox === document.activeElement){
				selbox.blur();
			} else {
				selbox.focus();
			}
		}


		if(e.keyCode==37){
			if(document.activeElement === document.getElementById("themeSelector")){
				console.log("selecting themes...");
			} else {
				curval = slider.value();
				if (curval > 0){slider.value(curval-1);}
			}
		}
		if(e.keyCode==39){
			if(document.activeElement === document.getElementById("themeSelector")){
				console.log("selecting themes...");
			} else {
				curval = slider.value();
				if (curval < dates.length-1){slider.value(curval+1);}
			}
			
		}
		
	}

  	var loadSlider=function(){return new Promise(function(resolve, reject){
		// remove existing slider
		if (slider_svg != null){
			slider_svg.remove();
		}

		// get available width
		var viewportwidth = $(window).width();
		var slider_width = 0.45*(viewportwidth);
		if(slider_width < 100){slider_width=100;};
		
		function dateString(sliderID){
			var date = dates[sliderID];
			var dateParsed = parseDate(date);
			var year = dateParsed[0];
			var month = dateParsed[1];
			var day = dateParsed[2];
			var r = day;
			// try to get 10 tick values
			
			var tickvals = slider.tickValues();
			// show Month if we're on the first day of the month
			if (sliderID==0 || day < parseDate(dates[sliderID-1])[1]){
				r = monthString(month) + ". " + day;
			}
			return r;
		}

		// load slider
		var circlepath ="M -7,0 A 7,7 0,0,1 7,0 A 7,7 180,0,1 -7,0 z"
		slider = d3
			.sliderHorizontal()
			.min(0)
			.max(dates.length-1)
			.step(1)
			.width(slider_width-60) // slider should be smaller than the svg
			.fill('#CA6')
			.handle(circlepath)
			.tickFormat(dateString)			
			.displayValue(true)
			.on('onchange', function(val) {
				sliderID=slider.value();
				curDate = dates[sliderID];
				d3.select('#value').text(curDate);
				updateMap(curDate,0,slider_update_duration,function(){return false;});
				});
		
		slider_svg = d3.select('#slider')
			.attr('align','center')
			.append('svg');
		slider_svg
			.attr('width', slider_width)
			.attr('height', 75)
			.attr('tabindex',0)
			.append('g')
			.attr('transform', 'translate(30,30)')
			.call(slider);
		// report that function worked
		resolve();
	})}

	
	loadData().then(function(){
		loadSlider().then(function(){
			// define current date
			curDate=dates[0];
			// load the map!		
			m = loadMap(base);
			// load the legend...
			loadLegend();
			// load the invisible tooltip div...
			loadTooltips();

			// set defaults, add event listeners
			document.onkeydown=handlekeydown;			
			document.getElementById("carttoggle").addEventListener("change",function(){toggle_map(1500);});
			document.getElementById("carttoggle").checked = false;
			document.getElementById("themeSelector").addEventListener("change",function(){loadTheme();});
			document.getElementById("dataSourceSelector").addEventListener("change",function(){loadData();});
			$('themeSelector').on('keydown', function(e){
				if(e.keyCode === 37 || e.keyCode === 39) { //left or right
					e.preventDefault();
					return false;
				}
			});
			
			
			// a bit of animation to show functionality
			setTimeout(function()
				{
		//			document.getElementById("carttoggle").checked = true;
		//			toggle_map(1500, function(){
						orig_duration = slider_update_duration;
						slider_update_duration = 1500;
						slider.value(dates.length-1);
						slider_update_duration = orig_duration;
			//		});
				},1000
			);
			console.log("finished loading.");
		});
	});

  </script>
</body>
</html>