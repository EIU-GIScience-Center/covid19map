<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate" />
  <meta http-equiv="Pragma" content="no-cache" />
  <meta http-equiv="Expires" content="0" />
  <link rel="stylesheet" href="d3_map_styles.css"> 
  <title>COVID-19 Open Visualization Toolkit</title>
  <script src="jquery-3.4.1.js"></script>
  <script src="jquery.csv-0.71.min.js"></script>
  <script src="papaparse.min.js"></script>
  <script src="d3.v5.js" charset="utf-8"></script>
  <script src="utils.js"></script>
  <script src="data/states_covidtracking_TEMPLATE/data_covidtracking_states.js"></script>
  <script src="data/counties_jhu/data_JHU_Illinois.js"></script>
  <script src="d3-simple-slider.min.js"></script>
  <script src="ResizeSensor.js"></script>
  <script src="legend_susielu.js"></script>
  <script src="themes/theme_cases_cumulative.js"></script>
  <script src="themes/theme_new_cases.js"></script>
  <script src="themes/theme_positive_test_ratio.js"></script>
  <script src="themes/theme_case_mortality.js"></script>
  <script src="themes/theme_increase_day_over_week.js"></script>
  <script src="themes/theme_increase_week_over_week_TEMPLATE.js"></script>

</head>

<body>
	<div id="opening_screen">
		<div id="maptop" style="text-align: center;margin-top:0ex; margin-bottom: 0ex;" >	
			<h3  style="margin-top:0ex; margin-bottom: 0ex;">Covid-19 Open Visualization (COViz) Toolkit </h3>
		</div>
						
		<div id="map"></div>
		<div id="mapbottom">
            <div id = "buttons">
            <button id="reset-button">Reset</button>
            <button id="faster-button">x2.0</button>    
            <button id="slower-button">x0.5</button>
            <button id="play-button">Play</button>
            </div>
			<div id="slider" style="align: center; float: left;"></div><div id="legend" style="align: center; float: right;"></div>
		</div>
		<div id="options" style="display: table; overflow: hidden; min-height: 100%;">
			<div style="display: table-cell; vertical-align: middle;">
				<table style="border:none; width: 90%; border-spacing: 15px;">
					<tr>
						<td>
							Data Source:
						</td>
						<td>
							<select class="select-css" id="dataSourceSelector">
							</select>			
						</td>
					</tr>
					<tr>
						<td>
							Map Theme:
						</td>
						<td>
							<select class="select-css" id="themeSelector">
							</select>
						</td>
					</tr>
					<tr>
						<td colspan=2 id="theme_brief_description">
						</td>
					</tr>

					<tr>
						<td>
							Map Type:
						</td>
						<td>
							<span>
								Map
                                <label class = "switch">
								<input id="carttoggle" type="checkbox">
								<span class="slider round"></span>
								</label>
								Cartogram
							</span>					
						</td>
					</tr>
					<tr>
						<td colspan=2 id="map_type_description">
					</td>
					</tr>
				</table>		  
			</div>
		</div>
	</div>
	<div id="below_screen">
	<H3> About </H3>
				<p>
				The Covid-19 Open Visualization (COViz) Toolkit is a modular open-source web toolkit for 
				hybrid map/graph visualization of COVID-19 risk burden, resource and testing sufficiency 
				and trajectories over time. In contrast to many dashboards that are data-driven and/or 
				built on proprietary software, COViz is an efficient, lightweight open platform that 
				focuses on use of sound cartographic principles to construct targeted visualizations 
				that intuitively communicate information relevant to specific epidemiological questions.
				These include:
				</p>
				<ul>
				<li>What is the current risk of transmission?</li>
				<li>What is the recent trajectory of disease burden and resource availability?</li>
				<li>How great is the cumulative burden of disease?</li>
				<li>Are resources and testing sufficient?</li>
				</ul>
				<p>
				To visually communicate answers to these questions, COViz aims to combine adherence to 
				traditional cartographic principles with innovative map forms and easy-to-use 
				animation/interaction components.
				</p>
				<H4>
				Traditional Cartographic Principles
				</H4>
				<ul>
				<li>All maps communicate rates per population. Raw case counts, hospitalizations and 
					deaths are meaningless without the context of the population within which they 
					are occurring.</li>
				<li>Rates are expressed using sequential color schemes, following the principles of 
					choropleth mapping.</li>
				<li>Raw counts, when shown, are expressed using proportional symbols, as symbol sizes 
					are intuitively associated with amounts.</li>
				<li>District polygons are highly generalized so that the focus is on the thematic 
					information, not the intricacies of the coastline.</li>
				</ul>
				<H4>
				Innovative Map Forms
				</H4>
				COViz features the use of cartograms. Also known as “population maps” and “density 
				equalizing map projections”, cartograms have been used in epidemiology since 
				<a href="https://ajph.aphapublications.org/doi/10.2105/AJPH.17.4.316"> at least the 
				1920s </a> to display districts at a size proportional to their underlying population. 
				This gives a better sense of the relative distribution of disease within the population. 
				While they take a little getting used to, cartograms enable certain advantages for visual 
				inference:
				<ul>
				<li>When symbols (e.g. circles) are used to show raw case counts, the case rate 
					(cases per population) can be inferred visually by the proportion of each 
					district occupied by the circle.</li>
				<li>When sequential colors (e.g. light to dark) are used to show case rates, the 
					total number of cases is proportional to the darkness value multiplied by the 
					size of the state.</li>
				<li>Symbols on a cartogram will have less overlap than on a regular map.</li>
				</ul>
				
				<H4>
				Animation and Interaction
				</H4>
				Some cartographic techniques that work well on static maps break down in animated sequences. We are currently experimenting with ways to enhance visual clarity on the animated timelines.
				
				
				<br>
				This is an open-source project. You are free to download, customize, modify data sources and 
				incorporate into your own website, with the caveat that no warranty is provided. 
				<br><br>
				Keyboard shortcuts (these work inconsistently at the moment):<br>
				<table style="border: none">
					<tr>
						<td>T</td>
						<td>Place focus on the theme selector</td>
					</tr>
					<tr>
						<td>&larr; &rarr;</td>
						<td>Move along timeline (when focus off var. sel.)</td>
					</tr>
					<tr>
						<td>L,P</td>
						<td>Toggle between land and population map types</td>
					</tr>
				</table>
				<p><i>(click on any state for data values)</i></p>
				<br>
				This website is being developed by the <a href="https://www.eiu.edu/gisci/">EIU GIScience Center</a>. 
				Data comes from <a href="https://covidtracking.com/">covidtracking.com</a>.  
				Latest project updates can be found on our <a href = "https://github.com/EIU-GIScience-Center/covid19map">github repository</a>.
				This is a work in progress. Feel free to send <a href="mailto: bjkronenfeld@eiu.edu">comments or feedback</a>.
				<br><br>
	</div>


<script>
	console.log("starting main script...");
	// load default dataset
	var active_feature = null;
	var active;
	var oncartogram = false;
	var curDate = null;
	var slider;
	var slider_svg;
	var slider_update_duration = 750;
	// map objects
	var mapsvg; // svg containing map 
	var circles; // svg group within mapsvg containing smaller circle for each state
	// map theme functions and values
	var theme;
	var dataSource;
	var choroplethColorScale; // scale function for legend (doesn't include white for zero)
	var lowValColor = null;
	var highValColor = null;
	var lowVal;
	var highVal;
	var dailymin;
	var dailymax;
    var timer;
	// array of themes
	// each theme should be defined in a separate file; see theme_new_cases.js for a template
	var themes = [
		themeNewCases_7day,
		themeNewCases,
		themeCaseIncreaseWeekOverWeek,
		themePositiveTestRatio,
		themeCasesCumulative,
		themeNewPositiveTestRatio,
		themeCaseMortality
	]

	// array of data sources
	// each data source should be defined in a separate file; see data_covidtracking_states.js for a template
	var dataSources = [
		dataCovidTracking_states,
		dataJHU_Illinois
	]

	function addThemesToSelector(datasource){
		// get selector object
		const themeSelector = document.getElementById("themeSelector");
		// clear existing themes
		themeSelector.options.length = 0;
		// add all themes that are valid with current data source
		for (i=0; i<themes.length; i++) {
			var cur_theme = themes[i];
			var req_var = cur_theme.requiredVariables;
			var themeValid = true;
			for(j=0;j<req_var.length;j++){
				if(datasource.variableNames.includes(req_var[j]) == false){
					themeValid = false;
				}
			}
			if(themeValid){
				const option = document.createElement("option");
				option.text=themes[i].themeName;
				themeSelector.add(option);
			}
			
		}
		
	}

	// Add datasets to the selector
	const dataSourceSelector = document.getElementById("dataSourceSelector");
	for (i=0; i<dataSources.length; ++i) {
		const option = document.createElement("option");
		option.text=dataSources[i].dataSourceName;
		dataSourceSelector.add(option);
	}

	function truncateCellsAndLabels(cells,labels, lowVal, highVal){
		// get indices of highest cell below lowVal, and lowest cell above highVal
		var lowIndex=0;
		var highIndex=cells.length-1;
		var gotHigh = false;
		for(i=0;i<cells.length;i++){
			if (cells[i] < lowVal){lowIndex = i;}
			if(gotHigh == false){
				if(cells[i] > highVal){
					highIndex = i; 
					gotHigh = true;
				}
			}
		}
		// slice even more if there is room
		var last_lb = theme.choroplethValueScale(cells[highIndex-1]);
		var last_ub = theme.choroplethValueScale(cells[highIndex]);
		
		right_buffer_proportion = (last_ub-theme.choroplethValueScale(highVal))/(last_ub-last_lb)
		if(right_buffer_proportion > 0.5 && cells.length > 2){highIndex -=1;};
		
		// slice out the corresponding section of the cells and labels
		cells = cells.slice(lowIndex, highIndex + 1);
		labels = labels.slice(lowIndex, highIndex + 1);
		return [cells,labels];
	}


	// Auto-Update the legend Values
	function myValueFunction(base, dates){
		maxmax = theme.choroplethValueFcn(base, dates);
		return maxmax
	}
	function dailymaxChoroplethValue(date, valuefunction){
		if(dataSource.baseFeatures, date == undefined){
			return "undefined";
		} else {
			var dailymax = valuefunction(dataSource.baseFeatures.features[0], date);
			for (i = 0; i < dataSource.baseFeatures.features.length; i++){
				var currentValue = valuefunction(dataSource.baseFeatures.features[i], date);
				if (currentValue > dailymax){
					dailymax = currentValue;
				}
			}
			return dailymax;
		}
	}

	function dailyminChoroplethValue(date, valuefunction){
		if(dataSource.baseFeatures, date == undefined){
			return "undefined";
		} else {   
			var dailymin = valuefunction(dataSource.baseFeatures.features[0], date);
			for (i = 0; i < dataSource.baseFeatures.features.length; i++){
				var currentValue = valuefunction(dataSource.baseFeatures.features[i], date);
				if (currentValue < dailymin){
					dailymin = currentValue;
				}
			}
			return dailymin;
		}
	}

	function updateValueRange(date){
		dailymin = dailyminChoroplethValue(date, myValueFunction);             
		dailymax = dailymaxChoroplethValue(date, myValueFunction);
		// truncate legend cells and labels to low and high values
		var unitIntervalScale = d3.scaleLinear()
		.domain([theme.choroplethValueScale(dailymin), theme.choroplethValueScale(dailymax)]);
		if(theme.invertColorScale){
			choroplethColorScale =d3.scaleSequential(function(d){
				return theme.choroplethColorInterpolator(1-unitIntervalScale(theme.choroplethValueScale(d)));
			});
		} else {
			choroplethColorScale =d3.scaleSequential(function(d){
				return theme.choroplethColorInterpolator(unitIntervalScale(theme.choroplethValueScale(d)));
			});
		
		}
	}

	function fixedValueRange(){
		var unitIntervalScale = d3.scaleLinear()
			.domain([theme.choroplethValueScale(theme.legendmin), theme.choroplethValueScale(theme.legendmax)]);
			if(theme.invertColorScale){
				choroplethColorScale =d3.scaleSequential(function(d){
					return theme.choroplethColorInterpolator(1-unitIntervalScale(theme.choroplethValueScale(d)));
				});
			} else {
				choroplethColorScale =d3.scaleSequential(function(d){
					return theme.choroplethColorInterpolator(unitIntervalScale(theme.choroplethValueScale(d)));
				});			
			}
    }
    
    function loadTheme() {
		// determine the new map theme
		var themeName = document.getElementById("themeSelector").value;		
		// Look for the theme in our theme modules
		const match = themes.find(v => v.themeName == themeName)
		if(dataSource !== undefined){
			if (match) {
				theme = match;
				// show the description of the theme
				document.getElementById("theme_brief_description").innerHTML ="<i>" + theme.briefDescription + "</i>";
				// calculate true legend/color/size scales based on theme parameters
				if(theme.invertColorScale){
					lowValColor = theme.choroplethColorInterpolator(1);
					highValColor = theme.choroplethColorInterpolator(0);
				} else {
					lowValColor = theme.choroplethColorInterpolator(0);
					highValColor = theme.choroplethColorInterpolator(1);
				}	
				// update the timer
				 clearInterval(timer);
				setTimeout(function()
					{
						orig_duration = slider_update_duration;
						slider_update_duration = 500;
						slider.value(dates.length-1);
						slider_update_duration = orig_duration;
					},500
				);
				playButton.text("Play");
				currentIndex = 35;
				// update the map and legend
				if (theme.updateDailyValueRange){
					updateValueRange(curDate);
				} else {
					fixedValueRange();
				}   
				updateMap();
				loadLegend();				
			} // found match
		} // datasource is defined
	} // loadTheme function

	var loadData = function() {
		return new Promise(function(resolve,reject){
			// get name from drop-down selector
			var dataSourceName = document.getElementById("dataSourceSelector").value;
			// find matching data source
			var match = dataSources.find(v => v.dataSourceName == dataSourceName);
			if(match){
				// get promised data object
				match.dataFunc.then(function(the_data_obj){
					dataSource = the_data_obj; // the data object is what we'll call the dataSource
					addThemesToSelector(dataSource); // determine which themes are valid for this data source
					// create a getValue function that can be used in themes
					getValue = function(feat, date, varName, perMillion=false, getIncrease = false){
						var featID = dataSource.getID(feat);
						var val;
						if(dataSource.dateDistrictData == undefined || featID == undefined){
							val=0;
						} else {
							var val = dataSource.dateDistrictData[date][featID][varName];
						}
						if(perMillion){val = val*1000000/dataSource.getPopulation(feat);}
						if(getIncrease){
							var yesterday = previousDate(date, dataSource.dates);
							if (yesterday != null){
								var yesterdayVal = getValue(feat,yesterday,varName,perMillion,false);				
								val = val-yesterdayVal
							}
						}		
						return val;
					}
					resolve();
				});
			};		
		});
	}
           
	function extendColorScale(initScale,inVal){
		if (lowValColor != null){
			if (inVal <= lowVal){
				console.log("value below lowVal.");
				return lowValColor;
			} 
		}
		if (highValColor != null){
			if (inVal >= highVal){
				console.log("value above lowVal.");
				return highValColor;
			}
		}
		return initScale(inVal);
	}
    
	function choroplethColor(feat,date){
		// assign a color based on rate per million
		var featval =theme.choroplethValueFcn(feat,date);
		return extendColorScale(choroplethColorScale,featval);
	}			
	
	function prjXFunction(scale,trans){
		var f = function(x){		
			return x*scale+trans;
		}
		return f;
	}

	function prjYFunction(scale,trans){
		// Why is this formula different for y than for x?? 
		// I have no idea, something to do with flipped coordinates... anyway this just works.
		var f = function(y){		
			return trans-y*scale;
		}
		return f;
	}

	
	function fitProjection(data, box, center) {
		// get the bounding box for the data - might be more efficient approaches
		var left = Infinity,
			bottom = Infinity,
			right = -Infinity,
			top = -Infinity;
		// get "projection"
		var projection = d3.geoIdentity().reflectY(true);
		// reset projection
		projection
			.scale(1)
			.translate([0, 0]);
		data.features.forEach(function(feature) {
			coords = feature.geometry.coordinates[0][0];
			var minX = d3.min(coords, function(array) {return array[0];});
			var maxX = d3.max(coords, function(array) {return array[0];});
			var minY = d3.min(coords, function(array) {return array[1];});
			var maxY = d3.max(coords, function(array) {return array[1];});
			if (minX < left) {left = minX;};
			if (maxX > right) {right = maxX;};
			if (minY < bottom) {bottom = minY;};
			if (maxY > top) {top = maxY;};
			
			});
		var temp = bottom;
		bottom = top;
		top =  temp;
		
		// project the bounding box, find aspect ratio
		function width(bb) {
			return (bb[1][0] - bb[0][0])
			}

		function height(bb) {
			return (bb[1][1] - bb[0][1]);
			}
		  
		function aspect(bb) {
			return width(bb) / height(bb);
			}		var startbox = [[left, top],  [right, bottom]],
			a1 = aspect(startbox),
			a2 = aspect(box),
			widthDetermined = a1 > a2,
			scale = widthDetermined ?
			// scales determined by width & height
			width(box) / width(startbox) :
			height(box) / height(startbox),
			// set x & y translations
			transX = box[0][0] - startbox[0][0] * scale,
			transY = box[0][1] - startbox[0][1] * scale;
		// center if requested
		if (center) {
			transY = transY - (transY + startbox[1][1] * scale - box[1][1])/2;
			transX = transX - (transX + startbox[1][0] * scale - box[1][0])/2;
		}
		
		// if using real projection (as opposed to geoIdentity), 
		// set precision to zero to prevent D3 from adding points through "adaptive sampling"
		return [projection.scale(scale).translate([transX, transY]),scale,transX,transY];
	}	

	// handle resizing
	new ResizeSensor(jQuery('#map'), function(){ 	
		if (curDate != null){
			// update map, legend and slider
			var curDateID = dataSource.dates.indexOf(curDate);
			if(oncartogram==true){
				m = loadMap(dataSource.cartogramFeatures);
			} else {
				m = loadMap(dataSource.baseFeatures);
			}
			updateMap();
			loadLegend();
			slider_svg.call(slider);
		}
	});		

	function featureInfoHTML(feature){
		if(theme != undefined){
			if(feature != null){
				var realDate = new Date(curDate)
				var monthID = realDate.getMonth()+1;
				var day = realDate.getDay();
				showHTML = "<B>" + dataSource.getLabel(feature) + " (" + monthString(monthID) + " " + day + ")</B><BR>";
				showHTML += theme.tooltipTextFcn(feature,curDate);
				return showHTML;
			} else {
				return "";
			}
		}
	}


	function loadMap(featdata,categories, category){
		console.log("loading map...");
		// make sure we have a data source
		if(dataSource !== undefined){		
			divid='map';
			var ele = document.getElementById(divid); // Do not use #
			var width = ele.clientWidth;
			var height = ele.clientHeight;
			
			divid = '#' + divid;
			d3.select(divid).selectAll('svg').remove();			
			mapsvg = d3.select(divid)
					.append('svg')
					.attr('width',width)
					.attr('height',height)
					.on('click',reset);
			var statepaths = mapsvg.append('g');
			var prj,scale,transX,transY;

			[prj,prjscale,transX,transY]=fitProjection(featdata, [[0, 0],  [width, height]], true)
			var path = d3.geoPath()
				.projection(prj);
			var bounds = path.bounds(featdata), 
				dx = bounds[1][0] - bounds[0][0],
				dy = bounds[1][1] - bounds[0][1],
				x = (bounds[0][0] + bounds[1][0]) / 2,
				y = (bounds[0][1] + bounds[1][1]) / 2,
				boundsscale = .9 / Math.max(dx / width, dy / height),
				translate = [width / 2 - boundsscale * x, height / 2 - boundsscale * y];
			statepaths.selectAll('path')
				.remove()
				.data(featdata.features)
				.enter()
				.append('path')
				.attr('d',path)
				.attr("class","feature")
				.attr("stroke", "#EEE")
				.attr("stroke-width", "1px")
				.attr("fill", "#FFFFCC") // function(d){return choroplethColor(d, curDate);})
				.attr("transform", "translate(" + translate + ")scale(" + boundsscale + ")")
				.on("click",feature_click)
				.on("mouseover",feature_mouseover)
				.on("mouseout",feature_mouseout);	

			circles = mapsvg.append('g');

			circles.selectAll('circle')
				.data(featdata.features)
				.enter()
				.append('circle')
				.attr("cx", function(d){
					var prjX = prjXFunction(prjscale,transX); 
					return prjX(centroid(d)[0]);
				})
				.attr("cy", function(d){
					var prjY = prjYFunction(prjscale,transY); 
					return prjY(centroid(d)[1]);
				})
				.attr("transform", "translate(" + translate + ")scale(" + boundsscale + ")")
				//.style('fill',theme.circleFill)
				//.style('stroke',theme.circlestroke)
				.style('stroke-width',1)
				.style('opacity',1)
				.on("click",feature_click)
				.on("mouseover",feature_mouseover)
				.on("mouseout",feature_mouseout);			
			statepaths.exit().remove();
			return statepaths;
		} // end if dataSource is not undefined
	}

	// toggles between the current base map and cartogram
	function toggle_map(milliseconds=1500, callback){
		oncartogram = !oncartogram;
		updateMap(milliseconds, delay=0, callback);
	}

	// updates map to the user selected type (map or cartogram) and date
	function updateMap(milliseconds=750,delay=0,callback){
		// change the text describing the map type
		var mapTypeDescription;
		if (oncartogram){
			mapTypeDescription = "The size of each state represents its <span style='color: #B37; font-weight: 700'>population</span>.";
		} else {
			mapTypeDescription = "The size of each state represents its <span style='color: #B37; font-weight: 700'>land area</span>.";
		}
		document.getElementById("map_type_description").innerHTML ="<i>" + mapTypeDescription + "</i>";
		
		// transition the map only if the map svg and date are defined
		if(mapsvg !== undefined){
			if(curDate != null){	
				var todata; // either map or cartogram features
				// get data and choropleth/symbol functions depending on if we're showing a map or cartogram
				var localChoroplethColor;
				var localCircleRadius;
				var localCircleFill = function(d){return choroplethColor(d, curDate);};
				var localFeatureStroke;
				if (oncartogram==false){
					todata=dataSource.baseFeatures;
					localChoroplethColor=function(d){return choroplethColor(d, curDate);};
					localFeatureStroke = '#DDD';
					localCircleRadius=0;
				} else {
					todata=dataSource.cartogramFeatures;
					if(theme.circleRadiusFcn==0){
						localChoroplethColor=function(d){return choroplethColor(d, curDate);};
						localFeatureStroke = '#DDD';
						localCircleRadius=0;
					} else {
						localFeatureStroke = '#CCC';
						localChoroplethColor='#F5F5F8';
						localCircleRadius=function(d){return theme.circleRadiusFcn(d,curDate);};
					}
				}

				// get scaling parameters based on current map width & height
				var ele = document.getElementById('map'); // Do not use #
				var width = ele.clientWidth;
				var height = ele.clientHeight;
				var prj,scale,transX,transY;
				[prj,prjscale,transX,transY]=fitProjection(todata, [[0, 0],  [width, height]], true)
				var path = d3.geoPath().projection(prj);
				
				var bounds = path.bounds(todata), 
					dx = bounds[1][0] - bounds[0][0],
					dy = bounds[1][1] - bounds[0][1],
					x = (bounds[0][0] + bounds[1][0]) / 2,
					y = (bounds[0][1] + bounds[1][1]) / 2,
					boundsscale = .9 / Math.max(dx / width, dy / height),
					translate = [width / 2 - boundsscale * x, height / 2 - boundsscale * y];

				// transition district polygons
				mapsvg.selectAll('path')
					.transition()
					.delay(delay)
					.ease(d3.easeLinear)
					.attr("d",function(d,i){return path(todata.features[i]);})
					.attr("transform", "translate(" + translate + ")scale(" + boundsscale + ")")
					.attr("fill",localChoroplethColor)
					.attr("stroke",localFeatureStroke)
					.duration(milliseconds)
					.on("end",callback);	

				// transition circle symbols
				mapsvg.selectAll('circle')
					.transition()
					.delay(delay)
					.attr("cx", function(d,i){
						var thisFeat = todata.features[i];				
						var prjX = prjXFunction(prjscale,transX); 
						return prjX(centroid(thisFeat)[0]);
					})
					.attr("cy", function(d,i){
						var thisFeat = todata.features[i];			
						var prjY = prjYFunction(prjscale,transY); 
						return prjY(centroid(thisFeat)[1]);
					})
					.attr('r',localCircleRadius)
					.style('fill',localCircleFill)
					.attr("transform", "translate(" + translate + ")scale(" + boundsscale + ")")
					.duration(milliseconds);
					
				// show info tooltip
				if(active_feature != null){showFeatureInfo(active_feature);}

			} // end if date is not null
		} // end if mapsvg is not null
	}



	function loadLegend(){
		// get available width
		var viewportwidth = $(window).width();
		var legwidth = 0.45*(viewportwidth);
		if(legwidth < 100){legwidth=100;};	
		// remove any existing legend
		d3.select("#legend").selectAll('svg').remove();			
		// create svg for new legend
		var legendsvg = d3.select("#legend")
			.attr('align','center')
			.append('svg')
			.attr('width',legwidth)
			.attr('height',60);		
		legendsvg.append("g")
		  .attr("class", "legendSequential")
		  .attr("transform", "translate(20,20)");
		// create legend
		var truncatedCells
        var truncatedLabels
        
        if (theme.updateDailyValueRange){
             [truncatedCells, truncatedLabels]=truncateCellsAndLabels(theme.choroplethCells, theme.choroplethLabels, dailymin, dailymax);
        } else {
            truncatedCells = theme.choroplethCells;
            truncatedLabels = theme.choroplethLabels;
        }        
		
        var numCells = truncatedCells.length;
		var legendSequential = d3.legendColor()
			.shapeWidth((legwidth-30)/numCells)
			.title(theme.choroplethLegendTitle)
			.cells(truncatedCells)
			.orient("horizontal")
			.labels(truncatedLabels)
			.scale(choroplethColorScale)
			.shapePadding(-1)
			.shapeHeight(15)
			.labelOffset(6); 
		// call function to draw legend in svg
		legendsvg.select(".legendSequential")
		  .call(legendSequential);
	}
    
	// show information when user selects or mouses over a feature	
	function showFeatureInfo(d){		
		// determine if tooltip will go above or below cursor
		d3.select('#tooltip')
			.style('opacity',1)
			.html(featureInfoHTML(d))
			.raise();
		if(d3.event != null){
			if(d3.event.pageY < window.innerHeight/3){
				d3.select('#tooltip')
					.style('left',(d3.event.pageX+10) + 'px')
					.style('top',(d3.event.pageY+10) + 'px')
					.style('bottom',null);		
			} else {			
				d3.select('#tooltip')
					.style('left',(d3.event.pageX+10) + 'px')
					.style('bottom',(window.innerHeight-d3.event.pageY) + 'px')
					.style('top',null);		
			}
		}
	}

	// processes user click on a specific district
	function feature_click(d,i) {
	  // d is the geometry object
	  // if user clicked on active feature, reset map
	  if (active_feature === d){return reset()};
	  // otherwise, set all features on both maps to inactive
	  m.selectAll(".active").classed("active", false);
	  // set user-clicked feature on both maps to active
	  d3.select(m.node().children[i]).
		classed("active", active = d);
	  d3.event.stopPropagation();
	  // record that we have an active feature
	  active_feature = d;
	  showFeatureInfo(d);
	}

	function feature_mouseover(d,i){
		if (active_feature == null){
			showFeatureInfo(d);
		}
	}

	function feature_mouseout(d,i){
		if (active_feature == null){
			d3.select('#tooltip').style('opacity',0);
		}
	}

	// unselect any selected features
	function reset() {
			m.selectAll(".active").classed("active", active = false);
			active_feature = null;
			m.transition().duration(750).attr("transform", "");
			d3.select('#tooltip').style('opacity',0);
	}

	function loadTooltips(){
		// load tooltips
		d3.select('body').
			append('div')
			.attr('id','tooltip')
			.style('position','absolute')
			.style('opacity',0)
			.style('padding','3px')
			.style('user-select','none')
			.style('stroke-alignment','inner');
	}

	// keyboard shortcuts
	function handlekeydown(e){	
		if(e.key=="p" || e.key=="P"){
			// switch to population map
			if(oncartogram==false){
				toggle_map(1500,function(){return false;});
				document.getElementById("carttoggle").checked=true;
			};
		}
		if(e.key=="l" || e.key=="L"){
			// switch to land map
			if(oncartogram==true){
				toggle_map(1500,function(){return false;});
				document.getElementById("carttoggle").checked=false;
			};
		}
		if(e.key=="t" || e.key=="T"){
			// set or remove focus for theme selector
			var selbox = document.getElementById("themeSelector");
			if(selbox === document.activeElement){
				selbox.blur();
			} else {
				selbox.focus();
			}
		}
		if(e.keyCode==37){
			if(document.activeElement === document.getElementById("themeSelector")){
				// console.log("selecting themes...");
			} else {
				curval = slider.value();
				if (curval > 0){slider.value(curval-1);}
			}
		}
		if(e.keyCode==39){
			if(document.activeElement === document.getElementById("themeSelector")){
				// console.log("selecting themes...");
			} else {
				curval = slider.value();
				if (curval < dataSource.dates.length-1){slider.value(curval+1);}
			}
		}
	}

  	var loadSlider=function(){return new Promise(function(resolve, reject){
		// remove existing slider
		if (slider_svg != null){
			slider_svg.remove();
		}
		// get available width
		var viewportwidth = $(window).width();
		var slider_width = 0.45*(viewportwidth);
		if(slider_width < 100){slider_width=100;};
		var secretCode="Yes please show month!";
		function dateString(sliderID, showMonthParam){
			sliderID = parseInt(sliderID);
			var date = new Date(dataSource.dates[sliderID]);
			var year = date.getFullYear();
			var month = date.getMonth()+1;
			var day = date.getDate();
			var r = day;
			// show Month if we're on the first day of the month
			if (sliderID==0 || date.getDate() < 8 || showMonthParam==secretCode){
				r = monthString(month) + " " + day;
			}
			return r;
		}
		slider_svg = d3.select('#slider')
			.attr('align','center')
			.append('svg');
		textData=[0];
		var dateTextGroup = slider_svg.selectAll("text")
			.data(textData)
			.enter()
			.append("text");
		// load slider
		var circlepath ="M -7,0 A 7,7 0,0,1 7,0 A 7,7 180,0,1 -7,0 z"
		slider = d3
			.sliderHorizontal()
			.min(0)
			.max(dataSource.dates.length-1)
			.ticks(10)
			.width(slider_width-60) // slider should be smaller than the svg
			.fill('#CA6')
			.handle(circlepath)
			.tickFormat(dateString)		
			.displayValue(true)
			.on('onchange', function(val) {
				sliderID=parseInt(slider.value());
				curDate = dataSource.dates[sliderID];
				slider.displayValue("Hi there!");
				d3.select('#value').text("???");
				var dateText = dateTextGroup
					.attr("x",function(d){return slider_width/2;})
					.attr("y",function(d){return 20;})
					.text(function(d){return dateString(sliderID,secretCode);})
					.attr("text-anchor","middle")
					.attr("font-family", "sans-serif")
					.attr("font-size", "15px")
					.attr("fill", "red");
                if (theme.updateDailyValueRange){
					updateValueRange(curDate);
                } else {
					fixedValueRange();
				}
                loadLegend()
				updateMap(slider_update_duration,0,function()   {return false;});
			});
		slider_svg
			.attr('width', slider_width)
			.attr('height', 75)
			.attr('tabindex',0)
			.append('g')
			.attr('transform', 'translate(30,30)')
			.call(slider);
		// report that function worked
		resolve();
	})}

	function handleDataLoaded(){return new Promise(function(resolve,reject){
		// update the slider
		loadSlider().then(function(){
			console.log("slider loaded:");
			// define current date
			curDate=dataSource.dates[0];
			// load the map!
			m = loadMap(dataSource.baseFeatures);
			//load the Theme
			loadTheme();
			// a bit of animation to show functionality
			setTimeout(function()
				{
					orig_duration = slider_update_duration;
					slider_update_duration = 500;
					slider.value(dataSource.dates.length-1);
					slider_update_duration = orig_duration;
				},500
			);
			// resolve promise
			resolve();
		});	
	})};
    
    

    var sliderID
    var currentIndex = sliderID;
    var playButton = d3.select("#play-button");
    var moving = false;
    var speed = 500;
    
    playButton
        .on("click", function() {
			var button = d3.select(this);
			if (button.text() == "Pause") {
			  moving = false;
			  clearInterval(timer);
			  // timer = 0;
			  button.text("Play");
			} else { 
              if (sliderID == dates.length-1) {
                  currentIndex = 35;
              } else {
              currentIndex = sliderID;
              }
			  moving = true;
			  speed = 500;
			  timer = setInterval(step, speed);
			  button.text("Pause");
			}
			console.log("Slider moving: " + moving);
		});
    
	function step(){
		var targetIndex = dates.length-1;
		curDate = dates[currentIndex];
		slider.value(currentIndex);
		updateMap();
		if (theme.updateDailyValueRange){
					updateValueRange(curDate);
                } else {
					fixedValueRange();
				}
		loadLegend();
		currentIndex = currentIndex + 1;
		if (currentIndex > targetIndex) {
			moving = false;
			currentIndex = 35;
			clearInterval(timer);
			// timer = 0;
			playButton.text("Play");
			console.log("Slider moving: " + moving);
		}   
	}
    
    var resetButton = d3.select("#reset-button");
        resetButton
            .on("click", function() {
				var button = d3.select(this);
				moving = false;
				clearInterval(timer);
				slider.value(dates.length-1);
				playButton.text("Play");
				currentIndex = 35;
				console.log("Slider moving: " + moving);
			})

    var slowerButton = d3.select("#slower-button");
        slowerButton
            .on("click", function() {
            var button = d3.select(this);
            clearInterval(timer);
            speed = speed + 250
            timer = setInterval(step, speed);
            playButton.text("Pause");
          });
    
    var fasterButton = d3.select("#faster-button");
		fasterButton
			.on("click", function() {
				var button = d3.select(this);
				clearInterval(timer);
				speed = speed - 250
				timer = setInterval(step, speed);
				playButton.text("Pause");
			});

	console.log("STARTING...");

	loadData().then(function(){
		handleDataLoaded().then(function(){
			
				
		});
	});

	// load the invisible tooltip div...
	loadTooltips();

	// set defaults, add event listeners
	document.onkeydown=handlekeydown;			
	document.getElementById("carttoggle").addEventListener("change",function(){
		toggle_map(1500);
	});
	//document.getElementById("carttoggle").checked = false;
	document.getElementById("themeSelector").addEventListener("change",function(){loadTheme();});
	document.getElementById("dataSourceSelector").addEventListener(
		"change",function(){
			loadData().then(
				function(){
					handleDataLoaded()
				}
			);
		}
	);
	$('themeSelector').on('keydown', function(e){
		if(e.keyCode === 37 || e.keyCode === 39) { //left or right
			e.preventDefault();
			return false;
		}
	});
		
	console.log("script finished.");
</script>

</body>
</html>