<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <link rel="stylesheet" href="d3_map_styles.css"> 
  <title>COVID-19 Rate Map - EIU GIScience Center</title>
  <script src="jquery-3.4.1.js"></script>
  <script src="https://d3js.org/d3.v5.js" charset="utf-8"></script>
  <!--<script src="USA_pop2010.js"></script> -->
  <script src="data/states_covidtracking/data_covidtracking_states.js"></script>
  <script src="d3-simple-slider.min.js"></script>
  <script src="ResizeSensor.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/4.2.2/d3.min.js"></script>
  <script src="legend_susielu.js"></script>
  <script src="utils.js"></script>
  <script src="themes/theme_cases_cumulative.js"></script>
  <script src="themes/theme_new_cases.js"></script>
  <script src="themes/theme_test_case_ratio.js"></script>
  <script src="themes/theme_new_test_case_ratio.js"></script>

</head>

<body>
	<div id="opening_screen">
		<div id="maptop" style="text-align: center;margin-top:0ex; margin-bottom: 0ex;" >	
			<h3  style="margin-top:0ex; margin-bottom: 0ex;">Covid-19 Open Visualization (COViz) Toolkit </h3>
		</div>
						
		<div id="map"></div>
		<div id="mapbottom">
			<div id="slider" style="align: center; float: left;"></div>							
			<div id="legend" style="align: center; float: right;"></div>								
		</div>
		<div id="options" style="display: table; overflow: hidden; min-height: 100%;">
			<div style="display: table-cell; vertical-align: middle;">
				<table style="border:none; width: 90%; border-spacing: 15px;">
					<tr>
						<td>
							Data Source:
						</td>
						<td>
							<select class="select-css" id="dataSourceSelector">
							</select>			
						</td>
					</tr>
					<tr>
						<td>
							Map Theme:
						</td>
						<td>
							<select class="select-css" id="themeSelector">
							</select>
						</td>
					</tr>
					<tr>
						<td>
							Map Type:
						</td>
						<td>
							<span>
								<u>L</u>and
								<label class = "switch">
								<input id="carttoggle" type="checkbox"">
								<span class="slider round"></span>
								</label>
								<u>P</u>opulation
							</span>					
						</td>
					</tr>
				</table>		  
			</div>
		</div>
	</div>
	<div id="below_screen">
	<H3> About </H3>
				<p>This web page provides a template for mapping information relevant to COVID-19, with the 
				goal of supporting informed decision-making by individuals and organizations. 
				Standardized map themes are being developed to communicate overall disease burden (case, 
				hospitalization and mortality rates), resource and testing sufficiency, and effects of 
				social distancing policy. All map themes will follow sound cartographic principles, and 
				timelines, animation and interactive components will allow exploration of past and current 
				trajectories of each variable. </p>
				
				<br>
				This is an open-source project. You are free to download, customize, modify data sources and 
				incorporate into your own website, with the caveat that no warranty is provided. 
				<br><br>
				Keyboard shortcuts (these work inconsistently at the moment):<BR>
				<table style="border: none">
					<tr>
						<td>T</td>
						<td>Place focus on the theme selector</td>
					</tr>
					<tr>
						<td>&larr; &rarr;</td>
						<td>Move along timeline (when focus off var. sel.)</td>
					</tr>
					<tr>
						<td>L,P</td>
						<td>Toggle between land and population map types</td>
					</tr>
				</table>
				<p><i>(click on any state for data values)</i></p>
				<br>
				This website is being developed by the <a href="https://www.eiu.edu/gisci/">EIU GIScience Center</a>. 
				Data comes from <a href="https://covidtracking.com/">covidtracking.com</a>.  
				Latest project updates can be found on our <a href = "https://github.com/EIU-GIScience-Center/covid19map">github repository</a>.
				This is a work in progress. Feel free to send <a href="mailto: bjkronenfeld@eiu.edu">comments or feedback</a>.
				<br><br>
	</div>
<script defer>
	// load default dataset
	const cr10 = Math.cbrt(10);
	var base;
	var cartogram;
	var active_feature = null;
	var active;
	var oncartogram = false;
	var dates;
	var districts;
	var dateDistrictData;
	var curDate = null;
	var slider;
	var slider_svg;
	var slider_update_duration = 750;
	// map objects
	var mapsvg; // svg containing map
	var statepaths; // svg group containing paths for each state
	var circles; // svg group containing smaller circle for each state
	// map theme functions and values
	var choroplethValue; // function to get value given feature, date
	var tooltipText; // function to get text for given value, given feature, date
	var choroplethColorScale; // scale function for legend (doesn't include white for zero)
	var lowValColor = null;
	var highValColor = null;
	var choroplethCellsAndLabels; // function returning [C,L] : legend symbol cells and corresponding labels;
	var choroplethLegTitle; // string text for legend title
	var circleRadius; // function to determine size of small circles
	var circleFill='#f47'; // fill color
	var circlestroke='#a05'; // stroke color
	
	var themes = [
		themeCasesCumulative,
		themeNewCases,
		themeTestCaseRatio,
		themeNewTestCaseRatio
    ]

	var dataSources = [
		dataCovidTracking_states
	]

	// Add modules to the selector
	const themeSelector = document.getElementById("themeSelector");
	for (i=0; i<themes.length; ++i) {
		const option = document.createElement("option");
		option.text=themes[i].themeName;
		themeSelector.add(option);
    }

	// Add datasets to the selector
	const dataSourceSelector = document.getElementById("dataSourceSelector");
	for (i=0; i<dataSources.length; ++i) {
		const option = document.createElement("option");
		option.text=dataSources[i].dataSourceName;
		dataSourceSelector.add(option);
    }

	const nthPowScale = function(n){
		return d3.scalePow()
			.exponent(n);
		};

	function area(coords){
		var a=0;
		for(let i=0; i<coords.length;i++){
			var j = i + 1;
			if(j==coords.length){j=0;}
			var xi=coords[i][0],yi=coords[i][1],xj=coords[j][0],yj=coords[j][1];
			a += (coords[j][0]-coords[i][0])*(coords[i][1]+coords[j][1]);
		}
		return a/2;
	}

	function coordCentroid(coords, A=-1){
		var cX=0, cY=0;
		if(A==-1){A = area(coords)}
		for(let i=0; i<coords.length;i++){
			var j = i + 1;
			if(j==coords.length){j=0;}
			var xi=coords[i][0],yi=coords[i][1],xj=coords[j][0],yj=coords[j][1];
			var cross = (xi*yj-xj*yi);
			cX += (xi+xj)*cross;
			cY += (yi+yj)*cross;
		}
		return [-cX/(6*A),-cY/(6*A)];
	}

	function centroid(feat,A=-1){
		var geo = feat['geometry'];
		var coordlists = geo['coordinates'];
		var maxArea=-1;
		var C;
		for(let i=0;i<coordlists.length;i++){
			var coords = coordlists[i][0];
			var A = area(coords);
			if(A > maxArea){	
				maxArea = A;
				C = coordCentroid(coords,A);
			}
		}
		return C;		
	}

	function periodAverage(feat, date, valFunc, periodWts){
		// computes the weighted average for days ending on the input date
		// function must take only feat and date as input
		// example: if weights are [1,0.5,0.25] then the return value
		// will be (1*today+0.5*yesterday+0.25*2daysage)/1.75
		// if the weights extend before the data start date, 
		// data will be averaged from the data start date
		var count=0;
		var valsum=0;
		var weightSum=0;
		var i=0;
		var d=date;
		while(d != null && i < periodWts.length){
			var curval = valFunc(feat,d);
			valsum += periodWts[i] * valFunc(feat, d);
			weightSum += periodWts[i];
			i += 1;
			d = previousDate(d);
		}
		return valsum/weightSum;
	}

	function extendColorScale(initScale,lowValColor, highValColor){
		return function(inVal){
			if (lowValColor != null){
				if (inVal <= lowValColor[0]){
					return lowValColor[1];
				} 
			}
			if (highValColor != null){
				if (inVal >= highValColor[0]){
					return highValColor[1];
				}
			}
			return initScale(inVal);
		}
	}

	function expBase10CellsAndLabelsFunc(minVal=1,maxVal=100000){
		var outFunc = function(){			
			var curVal = minVal;
			var legendCells = [];
			var legendLabels = [];
			while (curVal < maxVal + 1){
				// add to legend values and labels
				legendCells.push(curVal);
				if (Math.round(curVal)%10 == 0 || Math.round(curVal)==1){
					legendLabels.push(withCommas(Math.round(curVal)));
				} else {
					legendLabels.push("");
				}
				// increment
				curVal *= cr10; 
			}
			return [legendCells, legendLabels];
		}
		return outFunc;
	}

	function handleThemeChange(){
		// determine the new map theme
		var mapTheme = document.getElementById("themeSelector").value;		
		// Look for the theme in our theme modules
		const match = themes.find(v => v.themeName == mapTheme)
		if (match) {
			choroplethValue = match.choroplethValueFcn;
			tooltipText = match.tooltipTextFcn;
			choroplethColorScale = match.choroplethColorScale;
			lowValColor = match.lowValColor;
			highValColor = match.HighValColor;
			choroplethCellsAndLabels = match.cellsAndLabelsFcn;
			choroplethLegTitle = match.choroplethLegendTitle;
			circleRadius = match.circleRadiusFcn;
			circleFill = match.circleFill;
			circlestroke = match.circleStroke;
		}
		// update the map and legend
		updateMap();
		loadLegend();
	}

  	var loadData=function(){
		return new Promise(
			function(resolve, reject){
				// determine new data source
				var dataSource = document.getElementById("dataSourceSelector").value;		
				// find matching data source object
				const match = dataSources.find(v => v.dataSourceName == dataSource);
				if(match){
					data_func = match.dataFunc;
					Promise.resolve(data_func).then(function(data_obj){
						console.log("AFTER PROMISE RESOLVED");
						base = data_obj.baseFeatures;
						cartogram = data_obj.cartogramFeatures;
						dates = data_obj.dates;
						districtIDs = data_obj.districtIDs;
						dateDistrictData = data_obj.dateDistrictData;
						getID = data_obj.getID;
						getPopulation = data_obj.getPopulation;
						var getRawValue = data_obj.getValue;
						getValue = function(feat, date, varName, perMillion=false, getIncrease = false){
							var val = getRawValue(feat,date,varName);
							if(perMillion){val = val*1000000/getPopulation(feat);}
							if(getIncrease){
								var yesterday = previousDate(date);
								if (yesterday != null){
									var yesterdayVal = getValue(feat,yesterday,varName,perMillion,false);				
									val = val-yesterdayVal
								}
							}		
							return val;
						}
					resolve()
					})
				}
			}
		)
	};

	function extendedChoroplethColorScale(featVal){
		var colorScale = choroplethColorScale;
		colorScale = extendColorScale(colorScale, lowValColor,highValColor);
		return colorScale(featVal);
	}

	function choroplethColor(feat,date){
		// assign a color based on rate per million
		var featval =choroplethValue(feat,date);
		return extendedChoroplethColorScale(featval);
	}			
	
	function prjXFunction(scale,trans){
		var f = function(x){		
			return x*scale+trans;
		}
		return f;
	}

	function prjYFunction(scale,trans){
		// Why is this formula different for y than for x?? 
		// I have no idea, something to do with flipped coordinates... anyway this just works.
		var f = function(y){		
			return trans-y*scale;
		}
		return f;
	}

	
	function fitProjection(data, box, center) {
		// get the bounding box for the data - might be more efficient approaches
		var left = Infinity,
			bottom = Infinity,
			right = -Infinity,
			top = -Infinity;
		// get "projection"
		var projection = d3.geoIdentity().reflectY(true);
		// reset projection
		projection
			.scale(1)
			.translate([0, 0]);
		data.features.forEach(function(feature) {
			coords = feature.geometry.coordinates[0][0];
			var minX = d3.min(coords, function(array) {return array[0];});
			var maxX = d3.max(coords, function(array) {return array[0];});
			var minY = d3.min(coords, function(array) {return array[1];});
			var maxY = d3.max(coords, function(array) {return array[1];});
			if (minX < left) {left = minX;};
			if (maxX > right) {right = maxX;};
			if (minY < bottom) {bottom = minY;};
			if (maxY > top) {top = maxY;};
			
			});
		var temp = bottom;
		bottom = top;
		top =  temp;
		
		// project the bounding box, find aspect ratio
		function width(bb) {
			return (bb[1][0] - bb[0][0])
			}

		function height(bb) {
			return (bb[1][1] - bb[0][1]);
			}
		  
		function aspect(bb) {
			return width(bb) / height(bb);
			}
		var startbox = [[left, top],  [right, bottom]],
			a1 = aspect(startbox),
			a2 = aspect(box),
			widthDetermined = a1 > a2,
			scale = widthDetermined ?
			// scales determined by width & height
			width(box) / width(startbox) :
			height(box) / height(startbox),
			// set x & y translations
			transX = box[0][0] - startbox[0][0] * scale,
			transY = box[0][1] - startbox[0][1] * scale;
		// center if requested
		if (center) {
			transY = transY - (transY + startbox[1][1] * scale - box[1][1])/2;
			transX = transX - (transX + startbox[1][0] * scale - box[1][0])/2;
		}
		
		// if using real projection (as opposed to geoIdentity), 
		// set precision to zero to prevent D3 from adding points through "adaptive sampling"
		return [projection.scale(scale).translate([transX, transY]),scale,transX,transY];
	}	

	// switches map features to the given features
	function switchto(divid, newFeatSet, fromdata,milliseconds,callback){
		var ele = document.getElementById(divid); // Do not use #
		var width = ele.clientWidth;
		var height = ele.clientHeight;
		divid = '#' + divid;
		var prj,scale,transX,transY;
		[prj,prjscale,transX,transY]=fitProjection(newFeatSet, [[0, 0],  [width, height]], true)
		var path = d3.geoPath().projection(prj);
		
		var bounds = path.bounds(newFeatSet), 
			dx = bounds[1][0] - bounds[0][0],
			dy = bounds[1][1] - bounds[0][1],
			x = (bounds[0][0] + bounds[1][0]) / 2,
			y = (bounds[0][1] + bounds[1][1]) / 2,
			boundsscale = .9 / Math.max(dx / width, dy / height),
			translate = [width / 2 - boundsscale * x, height / 2 - boundsscale * y];

		
		m.selectAll('path')
			.transition()
			.attr("d",function(d,i){return path(newFeatSet.features[i]);})
			.attr("transform", "translate(" + translate + ")scale(" + boundsscale + ")")
			.duration(milliseconds)
			.on("end",callback);	
		
		mapsvg.selectAll('circle')
			.transition()
			.attr("cx", function(d,i){
				var thisFeat = newFeatSet.features[i];				
				var prjX = prjXFunction(prjscale,transX); 
				return prjX(centroid(thisFeat)[0]);
			})
			.attr("cy", function(d,i){
				var thisFeat = newFeatSet.features[i];			
				var prjY = prjYFunction(prjscale,transY); 
				return prjY(centroid(thisFeat)[1]);
			})
			.attr("transform", "translate(" + translate + ")scale(" + boundsscale + ")")
			.duration(milliseconds);
	}

	// toggles between the current base map and cartogram
	function toggle_map(milliseconds=1500, callback){
		if (oncartogram){
			switchto('map', base, cartogram, milliseconds, callback);
			}
		else{
			switchto('map', cartogram, base, milliseconds, callback);
			}
		oncartogram = !oncartogram;
	}


	// handle resizing
	new ResizeSensor(jQuery('#map'), function(){ 
		// rearrange divs
		//loadLegend();
		//loadSlider();
		// make sure theme is updated
		handleThemeChange();
		// update map
		if (curDate != null){
			if(oncartogram==true){
				m = loadMap(cartogram);
			} else {
				m = loadMap(base);
			}
			updateMap();
			loadSlider();
		}
	});		

	function featureInfoHTML(feature){
		if(feature != null){
			// show data for selected feature
			// population data is from feature itself
			var pop = feature.properties.POP_2010
			// remaining data is from "dateDistrictData" object, lookup by date and state
			var stateAbbrev = feature.properties.ABBREV;
			let [year, month, day] = parseDate(curDate);
			showHTML = "<B>" + feature.properties.STATE_NAME + " (" + monthString(month) + " " + day + ")</B><BR>";
			showHTML += tooltipText(feature,curDate);
			return showHTML;
		} else {
			return "";
		}
	}


	function loadMap(featdata,categories, category){
		divid='map';
		var ele = document.getElementById(divid); // Do not use #
		var width = ele.clientWidth;
		var height = ele.clientHeight;
		
		divid = '#' + divid;
		d3.select(divid).selectAll('svg').remove();			
		mapsvg = d3.select(divid)
				.append('svg')
				.attr('width',width)
				.attr('height',height)
				.on('click',reset);
		statepaths = mapsvg.append('g');
		var prj,scale,transX,transY;

		[prj,prjscale,transX,transY]=fitProjection(featdata, [[0, 0],  [width, height]], true)
		var path = d3.geoPath()
			.projection(prj);
		var bounds = path.bounds(featdata), 
			dx = bounds[1][0] - bounds[0][0],
			dy = bounds[1][1] - bounds[0][1],
			x = (bounds[0][0] + bounds[1][0]) / 2,
			y = (bounds[0][1] + bounds[1][1]) / 2,
			boundsscale = .9 / Math.max(dx / width, dy / height),
			translate = [width / 2 - boundsscale * x, height / 2 - boundsscale * y];
		statepaths.selectAll('path')
			.data(featdata.features)
			.enter()
			.append('path')
			.attr('d',path)
			.attr("class","feature")
			.attr("stroke", "#EEE")
			.attr("stroke-width", "1px")
			.attr("fill",function(d){return choroplethColor(d, curDate);})
			.attr("transform", "translate(" + translate + ")scale(" + boundsscale + ")")
			.on("click",feature_click)
			.on("mouseover",feature_mouseover)
			.on("mouseout",feature_mouseout);	

		circles = mapsvg.append('g');

		circles.selectAll('circle')
			.data(featdata.features)
			.enter()
			.append('circle')
			.attr("cx", function(d){
				var prjX = prjXFunction(prjscale,transX); 
				return prjX(centroid(d)[0]);
			})
			.attr("cy", function(d){
				var prjY = prjYFunction(prjscale,transY); 
				return prjY(centroid(d)[1]);
			})
			.attr("transform", "translate(" + translate + ")scale(" + boundsscale + ")")
			.style('fill',circleFill)
			.style('stroke',circlestroke)
			.style('stroke-width',1)
			.style('opacity',0.5);		
		statepaths.exit().remove();
		return statepaths;
	}

	function updateMap(delay=0,duration=750, callback){
		if(curDate != null){
			statepaths.selectAll('path')
				.transition()
				.attr("fill",function(d){return choroplethColor(d, curDate);})
				.delay(delay)
				.duration(duration)
				.on('end',callback);
			circles.selectAll('circle')
				.transition()
				.attr('r',function(d){return circleRadius(d,curDate);})
				.style('fill',circleFill)
				.style('stroke',circlestroke)
				.delay(delay)
				.duration(duration);
			if(active_feature != null){showFeatureInfo(active_feature);}
		}
	}

	function loadLegend(){
		/*
		var choroplethValue; // function to get value given feature, date
		var tooltipText; // function to get text for given value, given feature, date
		var choroplethColorScale; // scale function for legend (doesn't include white for zero)
		var extendedChoroplethColorScale; // scale function for map (includes white for zero) 
		var choroplethCellsAndLabels; // function returning [C,L] : legend symbol cells and corresponding labels;
		var choroplethLegTitle; // string text for legend title
		*/
		
		// get available width
		var viewportwidth = $(window).width();
		var legwidth = 0.45*(viewportwidth);
		if(legwidth < 100){legwidth=100;};
		
		
		d3.select("#legend").selectAll('svg').remove();			
		var legendsvg = d3.select("#legend")
			.attr('align','center')
			.append('svg')
			.attr('width',legwidth)
			.attr('height',60);
		
		legendsvg.append("g")
		  .attr("class", "legendSequential")
		  .attr("transform", "translate(20,20)");

		var legendCells = [];
		var legendLabels = [];
		[legendCells, legendLabels] = choroplethCellsAndLabels();	
		var numCells = legendCells.length;

		var legendSequential = d3.legendColor()
			.shapeWidth((legwidth-30)/numCells)
			.title(choroplethLegTitle)
			.cells(legendCells)
			.orient("horizontal")
			.labels(legendLabels)
			.scale(choroplethColorScale)
			.shapePadding(-1)
			.shapeHeight(15)
			.labelOffset(6); 

		legendsvg.select(".legendSequential")
		  .call(legendSequential);
	}


	// *** FUNCTIONS TO SHOW FEATURE INFO TO BE REPLACED BY TOOLTIP ***
	// show information when user selects or mouses over a feature
	
	function showFeatureInfo(d){		
		// determine if tooltip will go above or below cursor
		d3.select('#tooltip')
			.style('opacity',1)
			.html(featureInfoHTML(d))
			.raise();
		if(d3.event != null){
			if(d3.event.pageY < window.innerHeight/3){
				d3.select('#tooltip')
					.style('left',(d3.event.pageX+10) + 'px')
					.style('top',(d3.event.pageY+10) + 'px')
					.style('bottom',null);		
			} else {			
				d3.select('#tooltip')
					.style('left',(d3.event.pageX+10) + 'px')
					.style('bottom',(window.innerHeight-d3.event.pageY) + 'px')
					.style('top',null);		
			}
		}
	}


	// processes user click on a specific district
	function feature_click(d,i) {
	  // d is the geometry object
	  // if user clicked on active feature, reset map
	  if (active_feature === d){return reset()};
	  // otherwise, set all features on both maps to inactive
	  m.selectAll(".active").classed("active", false);
	  // set user-clicked feature on both maps to active
	  d3.select(m.node().children[i]).
		classed("active", active = d);
	  d3.event.stopPropagation();
	  // record that we have an active feature
	  active_feature = d;
	  showFeatureInfo(d);
	}


	function feature_mouseover(d,i){
		if (active_feature == null){
			showFeatureInfo(d);
		}
	}

	function feature_mouseout(d,i){
		if (active_feature == null){
			d3.select('#tooltip').style('opacity',0);
		}
	}


	// unselect any selected features
	function reset() {
			m.selectAll(".active").classed("active", active = false);
			active_feature = null;
			m.transition().duration(750).attr("transform", "");
			d3.select('#tooltip').style('opacity',0);
	}


	function loadTooltips(){
		// load tooltips
		d3.select('body').
			append('div')
			.attr('id','tooltip')
			.style('position','absolute')
			.style('opacity',0)
			.style('padding','3px')
			.style('user-select','none')
			.style('stroke-alignment','inner');
		/*
		d3.select('#map').selectAll('svg').selectAll('path')
			.on('mouseover',function(d){
		d3.select('#tooltip')
					.style('left',(d3.event.pageX+10) + 'px')
					.style('bottom',(window.innerHeight-d3.event.pageY) + 'px');		
			})
			.on('mouseout',feature_mouseout)
			.on('mousemove',function(){
				
			});
		*/
	}



	// handle keypress
	function handlekeydown(e){
		if(e.key=="p" || e.key=="P"){
			// switch to population map
			if(oncartogram==false){
				toggle_map(1500,function(){return false;});
				document.getElementById("carttoggle").checked=true;
			};
		}
		if(e.key=="l" || e.key=="L"){
			// switch to land map
			if(oncartogram==true){
				toggle_map(1500,function(){return false;});
				document.getElementById("carttoggle").checked=false;
			};
		}

		if(e.key=="t" || e.key=="T"){
			// set or remove focus for theme selector
			var selbox = document.getElementById("themeSelector");
			if(selbox === document.activeElement){
				selbox.blur();
			} else {
				selbox.focus();
			}
		}


		if(e.keyCode==37){
			if(document.activeElement === document.getElementById("themeSelector")){
				console.log("selecting themes...");
			} else {
				curval = slider.value();
				if (curval > 0){slider.value(curval-1);}
			}
		}
		if(e.keyCode==39){
			if(document.activeElement === document.getElementById("themeSelector")){
				console.log("selecting themes...");
			} else {
				curval = slider.value();
				if (curval < dates.length-1){slider.value(curval+1);}
			}
			
		}
		
	}

	

  	var loadSlider=function(){return new Promise(function(resolve, reject){
		// remove existing slider
		if (slider_svg != null){
			slider_svg.remove();
		}

		// get available width
		var viewportwidth = $(window).width();
		var slider_width = 0.45*(viewportwidth);
		if(slider_width < 100){slider_width=100;};
		
		function dateString(sliderID){
			var date = dates[sliderID];
			var dateParsed = parseDate(date);
			var year = dateParsed[0];
			var month = dateParsed[1];
			var day = dateParsed[2];
			var r = day;
			// try to get 10 tick values
			
			var tickvals = slider.tickValues();
			// show Month if we're on the first day of the month
			if (sliderID==0 || day < parseDate(dates[sliderID-1])[1]){
				r = monthString(month) + ". " + day;
			}
			return r;
		}

		// load slider
		var circlepath ="M -7,0 A 7,7 0,0,1 7,0 A 7,7 180,0,1 -7,0 z"
		slider = d3
			.sliderHorizontal()
			.min(0)
			.max(dates.length-1)
			.step(1)
			.width(slider_width-60) // slider should be smaller than the svg
			.fill('#CA6')
			.handle(circlepath)
			.tickFormat(dateString)			
			.displayValue(true)
			.on('onchange', function(val) {
				sliderID=slider.value();
				curDate = dates[sliderID];
				d3.select('#value').text(curDate);
				updateMap(0,slider_update_duration,function(){return false;});
				});
		
		slider_svg = d3.select('#slider')
			.attr('align','center')
			.append('svg');
		slider_svg
			.attr('width', slider_width)
			.attr('height', 75)
			.attr('tabindex',0)
			.append('g')
			.attr('transform', 'translate(30,30)')
			.call(slider);
		// report that function worked
		resolve();
	})}

	
	loadData().then(function(){
		loadSlider().then(function(){
			// define current date
			curDate=dates[0];
			// load the map!		
			m = loadMap(base);
			// load the legend...
			loadLegend();
			// load the invisible tooltip div...
			loadTooltips();

			// set defaults, add event listeners
			document.onkeydown=handlekeydown;			
			document.getElementById("carttoggle").addEventListener("change",function(){toggle_map(1500);});
			document.getElementById("carttoggle").checked = false;
			document.getElementById("themeSelector").addEventListener("change",function(){handleThemeChange();});
			document.getElementById("dataSourceSelector").addEventListener("change",function(){handleDataSourceChange();});
			$('themeSelector').on('keydown', function(e){
				if(e.keyCode === 37 || e.keyCode === 39) { //left or right
					e.preventDefault();
					return false;
				}
			});
			
			
			// a bit of animation to show functionality
			setTimeout(function()
				{
		//			document.getElementById("carttoggle").checked = true;
		//			toggle_map(1500, function(){
						orig_duration = slider_update_duration;
						slider_update_duration = 1500;
						slider.value(dates.length-1);
						slider_update_duration = orig_duration;
			//		});
				},1000
			);
			console.log("finished loading.");
		});
	});

  </script>
</body>
</html>